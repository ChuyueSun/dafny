Build started 10/15/2022 21:22:05.
     1>Project "/home/livia/dafny/Source/IntegrationTests/IntegrationTests.csproj" on node 1 (Restore target(s)).
     1>_GetAllRestoreProjectPathItems:
         Determining projects to restore...
       Restore:
         X.509 certificate chain validation will use the fallback certificate bundle at '/usr/share/dotnet/sdk/6.0.402/trustedroots/codesignctl.pem'.
         Assets file has not changed. Skipping assets file writing. Path: /home/livia/dafny/Source/DafnyDriver/obj/project.assets.json
         Assets file has not changed. Skipping assets file writing. Path: /home/livia/dafny/Source/DafnyCore/obj/project.assets.json
         Assets file has not changed. Skipping assets file writing. Path: /home/livia/dafny/Source/DafnyRuntime/obj/project.assets.json
         Assets file has not changed. Skipping assets file writing. Path: /home/livia/dafny/Source/DafnyLanguageServer/obj/project.assets.json
         Assets file has not changed. Skipping assets file writing. Path: /home/livia/dafny/Source/DafnyPipeline/obj/project.assets.json
         Assets file has not changed. Skipping assets file writing. Path: /home/livia/dafny/Source/TestDafny/obj/project.assets.json
         Assets file has not changed. Skipping assets file writing. Path: /home/livia/dafny/Source/Dafny/obj/project.assets.json
         Restored /home/livia/dafny/Source/DafnyDriver/DafnyDriver.csproj (in 409 ms).
         Assets file has not changed. Skipping assets file writing. Path: /home/livia/dafny/Source/XUnitExtensions/obj/project.assets.json
         Restored /home/livia/dafny/Source/XUnitExtensions/XUnitExtensions.csproj (in 409 ms).
         Restored /home/livia/dafny/Source/DafnyCore/DafnyCore.csproj (in 409 ms).
         Restored /home/livia/dafny/Source/DafnyRuntime/DafnyRuntime.csproj (in 409 ms).
         Restored /home/livia/dafny/Source/DafnyLanguageServer/DafnyLanguageServer.csproj (in 409 ms).
         Restored /home/livia/dafny/Source/DafnyPipeline/DafnyPipeline.csproj (in 408 ms).
         Restored /home/livia/dafny/Source/TestDafny/TestDafny.csproj (in 409 ms).
         Restored /home/livia/dafny/Source/Dafny/Dafny.csproj (in 409 ms).
         Assets file has not changed. Skipping assets file writing. Path: /home/livia/dafny/Source/DafnyTestGeneration/obj/project.assets.json
         Restored /home/livia/dafny/Source/DafnyTestGeneration/DafnyTestGeneration.csproj (in 2 ms).
         Assets file has not changed. Skipping assets file writing. Path: /home/livia/dafny/Source/IntegrationTests/obj/project.assets.json
         Restored /home/livia/dafny/Source/IntegrationTests/IntegrationTests.csproj (in 10 ms).
         Assets file has not changed. Skipping assets file writing. Path: /home/livia/dafny/Source/DafnyServer/obj/project.assets.json
         Restored /home/livia/dafny/Source/DafnyServer/DafnyServer.csproj (in 18 ms).
         
         NuGet Config files used:
             /home/livia/.nuget/NuGet/NuGet.Config
         
         Feeds used:
             https://api.nuget.org/v3/index.json
         All projects are up-to-date for restore.
     1>Done Building Project "/home/livia/dafny/Source/IntegrationTests/IntegrationTests.csproj" (Restore target(s)).
   1:7>Project "/home/livia/dafny/Source/IntegrationTests/IntegrationTests.csproj" on node 5 (VSTest target(s)).
     1>BuildProject:
         Build started, please wait...
   1:7>Project "/home/livia/dafny/Source/IntegrationTests/IntegrationTests.csproj" (1:7) is building "/home/livia/dafny/Source/IntegrationTests/IntegrationTests.csproj" (1:8) on node 5 (default targets).
   1:8>Project "/home/livia/dafny/Source/IntegrationTests/IntegrationTests.csproj" (1:8) is building "/home/livia/dafny/Source/DafnyCore/DafnyCore.csproj" (4:8) on node 5 (default targets).
     4>RunCoco:
       Skipping target "RunCoco" because all output files are up-to-date with respect to the input files.
       GenerateTargetFrameworkMonikerAttribute:
       Skipping target "GenerateTargetFrameworkMonikerAttribute" because all output files are up-to-date with respect to the input files.
       CoreGenerateAssemblyInfo:
       Skipping target "CoreGenerateAssemblyInfo" because all output files are up-to-date with respect to the input files.
       CoreCompile:
       Skipping target "CoreCompile" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectory:
       Skipping target "_CopyOutOfDateSourceItemsToOutputDirectory" because all output files are up-to-date with respect to the input files.
       GenerateBuildDependencyFile:
       Skipping target "GenerateBuildDependencyFile" because all output files are up-to-date with respect to the input files.
   1:8>Project "/home/livia/dafny/Source/IntegrationTests/IntegrationTests.csproj" (1:8) is building "/home/livia/dafny/Source/DafnyRuntime/DafnyRuntime.csproj" (8:7) on node 3 (default targets).
     8>BuildDafnyRuntimeJar:
         Compiling DafnyRuntimeJava to DafnyRuntimeJava/build/libs/DafnyRuntime.jar...
     4>CopyFilesToOutputDirectory:
         DafnyCore -> /home/livia/dafny/Binaries/net6.0/DafnyCore.dll
     8>BuildDafnyRuntimeJar:
         ./gradlew -q build
   1:8>Project "/home/livia/dafny/Source/IntegrationTests/IntegrationTests.csproj" (1:8) is building "/home/livia/dafny/Source/XUnitExtensions/XUnitExtensions.csproj" (7:7) on node 7 (default targets).
     7>GenerateTargetFrameworkMonikerAttribute:
       Skipping target "GenerateTargetFrameworkMonikerAttribute" because all output files are up-to-date with respect to the input files.
       CoreGenerateAssemblyInfo:
       Skipping target "CoreGenerateAssemblyInfo" because all output files are up-to-date with respect to the input files.
       CoreCompile:
       Skipping target "CoreCompile" because all output files are up-to-date with respect to the input files.
       _CopyFilesMarkedCopyLocal:
         Copying file from "/home/livia/.nuget/packages/microsoft.testplatform.objectmodel/16.9.4/lib/netstandard2.0/Microsoft.TestPlatform.PlatformAbstractions.dll" to "/home/livia/dafny/Source/XUnitExtensions/bin/Debug/net6.0/Microsoft.TestPlatform.PlatformAbstractions.dll".
         Touching "/home/livia/dafny/Source/XUnitExtensions/obj/Debug/net6.0/XUnitExtensions.csproj.CopyComplete".
       _CopyOutOfDateSourceItemsToOutputDirectory:
       Building target "_CopyOutOfDateSourceItemsToOutputDirectory" partially, because some output files are out of date with respect to their input files.
         Copying file from "/home/livia/.nuget/packages/microsoft.testplatform.testhost/16.9.4/build/netcoreapp2.1/Microsoft.TestPlatform.PlatformAbstractions.dll" to "/home/livia/dafny/Source/XUnitExtensions/bin/Debug/net6.0/Microsoft.TestPlatform.PlatformAbstractions.dll".
       GenerateBuildDependencyFile:
       Skipping target "GenerateBuildDependencyFile" because all output files are up-to-date with respect to the input files.
       GenerateBuildRuntimeConfigurationFiles:
       Skipping target "GenerateBuildRuntimeConfigurationFiles" because all output files are up-to-date with respect to the input files.
       CopyFilesToOutputDirectory:
         XUnitExtensions -> /home/livia/dafny/Source/XUnitExtensions/bin/Debug/net6.0/XUnitExtensions.dll
     7>Done Building Project "/home/livia/dafny/Source/XUnitExtensions/XUnitExtensions.csproj" (default targets).
     4>GenerateNuspec:
       Skipping target "GenerateNuspec" because all output files are up-to-date with respect to the input files.
     4>Done Building Project "/home/livia/dafny/Source/DafnyCore/DafnyCore.csproj" (default targets).
   1:8>Project "/home/livia/dafny/Source/IntegrationTests/IntegrationTests.csproj" (1:8) is building "/home/livia/dafny/Source/DafnyLanguageServer/DafnyLanguageServer.csproj" (9:6) on node 8 (default targets).
     9>GenerateTargetFrameworkMonikerAttribute:
       Skipping target "GenerateTargetFrameworkMonikerAttribute" because all output files are up-to-date with respect to the input files.
       CoreGenerateAssemblyInfo:
       Skipping target "CoreGenerateAssemblyInfo" because all output files are up-to-date with respect to the input files.
       CoreCompile:
       Skipping target "CoreCompile" because all output files are up-to-date with respect to the input files.
       _CreateAppHost:
       Skipping target "_CreateAppHost" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectory:
       Skipping target "_CopyOutOfDateSourceItemsToOutputDirectory" because all output files are up-to-date with respect to the input files.
       GenerateBuildDependencyFile:
       Skipping target "GenerateBuildDependencyFile" because all output files are up-to-date with respect to the input files.
       GenerateBuildRuntimeConfigurationFiles:
       Skipping target "GenerateBuildRuntimeConfigurationFiles" because all output files are up-to-date with respect to the input files.
       CopyFilesToOutputDirectory:
         DafnyLanguageServer -> /home/livia/dafny/Binaries/DafnyLanguageServer.dll
     9>Done Building Project "/home/livia/dafny/Source/DafnyLanguageServer/DafnyLanguageServer.csproj" (default targets).
     8>GenerateTargetFrameworkMonikerAttribute:
       Skipping target "GenerateTargetFrameworkMonikerAttribute" because all output files are up-to-date with respect to the input files.
       CoreCompile:
       Skipping target "CoreCompile" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectory:
       Skipping target "_CopyOutOfDateSourceItemsToOutputDirectory" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectoryAlways:
         Copying file from "/home/livia/dafny/Source/DafnyRuntime/DafnyRuntime.cs" to "/home/livia/dafny/Binaries/net6.0/DafnyRuntime.cs".
       GenerateBuildDependencyFile:
       Skipping target "GenerateBuildDependencyFile" because all output files are up-to-date with respect to the input files.
       CopyFilesToOutputDirectory:
         DafnyRuntime -> /home/livia/dafny/Binaries/net6.0/DafnyRuntime.dll
   8:7>Project "/home/livia/dafny/Source/DafnyRuntime/DafnyRuntime.csproj" (8:7) is building "/home/livia/dafny/Source/DafnyRuntime/DafnyRuntime.csproj" (8:12) on node 7 (_GetFrameworkAssemblyReferences target(s)).
     8>BuildDafnyRuntimeJar:
         Compiling DafnyRuntimeJava to DafnyRuntimeJava/build/libs/DafnyRuntime.jar...
         ./gradlew -q build
     8>Done Building Project "/home/livia/dafny/Source/DafnyRuntime/DafnyRuntime.csproj" (_GetFrameworkAssemblyReferences target(s)).
     8>GenerateNuspec:
       Skipping target "GenerateNuspec" because all output files are up-to-date with respect to the input files.
     8>Done Building Project "/home/livia/dafny/Source/DafnyRuntime/DafnyRuntime.csproj" (default targets).
   1:8>Project "/home/livia/dafny/Source/IntegrationTests/IntegrationTests.csproj" (1:8) is building "/home/livia/dafny/Source/TestDafny/TestDafny.csproj" (6:6) on node 6 (default targets).
   6:6>Project "/home/livia/dafny/Source/TestDafny/TestDafny.csproj" (6:6) is building "/home/livia/dafny/Source/DafnyPipeline/DafnyPipeline.csproj" (10:12) on node 6 (default targets).
    10>CoreCompile:
       Skipping target "CoreCompile" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectory:
       Skipping target "_CopyOutOfDateSourceItemsToOutputDirectory" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectoryAlways:
         Copying file from "/home/livia/dafny/Source/DafnyRuntime/DafnyRuntime.cs" to "/home/livia/dafny/Binaries/DafnyRuntime.cs".
       GenerateBuildDependencyFile:
       Skipping target "GenerateBuildDependencyFile" because all output files are up-to-date with respect to the input files.
       CopyFilesToOutputDirectory:
         DafnyPipeline -> /home/livia/dafny/Binaries/DafnyPipeline.dll
       GenerateNuspec:
       Skipping target "GenerateNuspec" because all output files are up-to-date with respect to the input files.
    10>Done Building Project "/home/livia/dafny/Source/DafnyPipeline/DafnyPipeline.csproj" (default targets).
   1:8>Project "/home/livia/dafny/Source/IntegrationTests/IntegrationTests.csproj" (1:8) is building "/home/livia/dafny/Source/DafnyServer/DafnyServer.csproj" (5:8) on node 4 (default targets).
     5>GenerateTargetFrameworkMonikerAttribute:
       Skipping target "GenerateTargetFrameworkMonikerAttribute" because all output files are up-to-date with respect to the input files.
       CoreCompile:
       Skipping target "CoreCompile" because all output files are up-to-date with respect to the input files.
       _CreateAppHost:
       Skipping target "_CreateAppHost" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectory:
       Skipping target "_CopyOutOfDateSourceItemsToOutputDirectory" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectoryAlways:
         Copying file from "/home/livia/dafny/Source/DafnyRuntime/DafnyRuntime.cs" to "/home/livia/dafny/Binaries/DafnyRuntime.cs".
       _CopyAppConfigFile:
       Skipping target "_CopyAppConfigFile" because all output files are up-to-date with respect to the input files.
       GenerateBuildDependencyFile:
       Skipping target "GenerateBuildDependencyFile" because all output files are up-to-date with respect to the input files.
       GenerateBuildRuntimeConfigurationFiles:
       Skipping target "GenerateBuildRuntimeConfigurationFiles" because all output files are up-to-date with respect to the input files.
       CopyFilesToOutputDirectory:
         DafnyServer -> /home/livia/dafny/Binaries/DafnyServer.dll
     5>Done Building Project "/home/livia/dafny/Source/DafnyServer/DafnyServer.csproj" (default targets).
   6:6>Project "/home/livia/dafny/Source/TestDafny/TestDafny.csproj" (6:6) is building "/home/livia/dafny/Source/DafnyTestGeneration/DafnyTestGeneration.csproj" (11:9) on node 5 (default targets).
    11>GenerateTargetFrameworkMonikerAttribute:
       Skipping target "GenerateTargetFrameworkMonikerAttribute" because all output files are up-to-date with respect to the input files.
       CoreCompile:
       Skipping target "CoreCompile" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectory:
       Skipping target "_CopyOutOfDateSourceItemsToOutputDirectory" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectoryAlways:
         Copying file from "/home/livia/dafny/Source/DafnyRuntime/DafnyRuntime.cs" to "/home/livia/dafny/Source/DafnyTestGeneration/bin/Debug/net6.0/DafnyRuntime.cs".
       GenerateBuildDependencyFile:
       Skipping target "GenerateBuildDependencyFile" because all output files are up-to-date with respect to the input files.
       CopyFilesToOutputDirectory:
         DafnyTestGeneration -> /home/livia/dafny/Source/DafnyTestGeneration/bin/Debug/net6.0/DafnyTestGeneration.dll
    11>Done Building Project "/home/livia/dafny/Source/DafnyTestGeneration/DafnyTestGeneration.csproj" (default targets).
   1:8>Project "/home/livia/dafny/Source/IntegrationTests/IntegrationTests.csproj" (1:8) is building "/home/livia/dafny/Source/DafnyDriver/DafnyDriver.csproj" (3:6) on node 1 (default targets).
     3>GenerateTargetFrameworkMonikerAttribute:
       Skipping target "GenerateTargetFrameworkMonikerAttribute" because all output files are up-to-date with respect to the input files.
       CoreCompile:
       Skipping target "CoreCompile" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectory:
       Skipping target "_CopyOutOfDateSourceItemsToOutputDirectory" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectoryAlways:
         Copying file from "/home/livia/dafny/Source/DafnyRuntime/DafnyRuntime.cs" to "/home/livia/dafny/Binaries/DafnyRuntime.cs".
       _CopyAppConfigFile:
       Skipping target "_CopyAppConfigFile" because all output files are up-to-date with respect to the input files.
       GenerateBuildDependencyFile:
       Skipping target "GenerateBuildDependencyFile" because all output files are up-to-date with respect to the input files.
       CopyFilesToOutputDirectory:
         DafnyDriver -> /home/livia/dafny/Binaries/DafnyDriver.dll
     3>Done Building Project "/home/livia/dafny/Source/DafnyDriver/DafnyDriver.csproj" (default targets).
   1:8>Project "/home/livia/dafny/Source/IntegrationTests/IntegrationTests.csproj" (1:8) is building "/home/livia/dafny/Source/Dafny/Dafny.csproj" (2:7) on node 2 (default targets).
     2>GenerateTargetFrameworkMonikerAttribute:
       Skipping target "GenerateTargetFrameworkMonikerAttribute" because all output files are up-to-date with respect to the input files.
       CoreGenerateAssemblyInfo:
       Skipping target "CoreGenerateAssemblyInfo" because all output files are up-to-date with respect to the input files.
       CoreCompile:
       Skipping target "CoreCompile" because all output files are up-to-date with respect to the input files.
       _CreateAppHost:
       Skipping target "_CreateAppHost" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectory:
       Skipping target "_CopyOutOfDateSourceItemsToOutputDirectory" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectoryAlways:
         Copying file from "/home/livia/dafny/Source/DafnyRuntime/DafnyRuntime.cs" to "/home/livia/dafny/Binaries/DafnyRuntime.cs".
       GenerateBuildDependencyFile:
       Skipping target "GenerateBuildDependencyFile" because all output files are up-to-date with respect to the input files.
       GenerateBuildRuntimeConfigurationFiles:
       Skipping target "GenerateBuildRuntimeConfigurationFiles" because all output files are up-to-date with respect to the input files.
       CopyFilesToOutputDirectory:
         Dafny -> /home/livia/dafny/Binaries/Dafny.dll
     2>Done Building Project "/home/livia/dafny/Source/Dafny/Dafny.csproj" (default targets).
     6>GenerateTargetFrameworkMonikerAttribute:
       Skipping target "GenerateTargetFrameworkMonikerAttribute" because all output files are up-to-date with respect to the input files.
       CoreGenerateAssemblyInfo:
       Skipping target "CoreGenerateAssemblyInfo" because all output files are up-to-date with respect to the input files.
       CoreCompile:
       Skipping target "CoreCompile" because all output files are up-to-date with respect to the input files.
       _CreateAppHost:
       Skipping target "_CreateAppHost" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectory:
       Skipping target "_CopyOutOfDateSourceItemsToOutputDirectory" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectoryAlways:
         Copying file from "/home/livia/dafny/Source/DafnyRuntime/DafnyRuntime.cs" to "/home/livia/dafny/Source/TestDafny/bin/Debug/net6.0/DafnyRuntime.cs".
       GenerateBuildDependencyFile:
       Skipping target "GenerateBuildDependencyFile" because all output files are up-to-date with respect to the input files.
       GenerateBuildRuntimeConfigurationFiles:
       Skipping target "GenerateBuildRuntimeConfigurationFiles" because all output files are up-to-date with respect to the input files.
       CopyFilesToOutputDirectory:
         TestDafny -> /home/livia/dafny/Source/TestDafny/bin/Debug/net6.0/TestDafny.dll
     6>Done Building Project "/home/livia/dafny/Source/TestDafny/TestDafny.csproj" (default targets).
     1>GenerateTargetFrameworkMonikerAttribute:
       Skipping target "GenerateTargetFrameworkMonikerAttribute" because all output files are up-to-date with respect to the input files.
       CoreGenerateAssemblyInfo:
       Skipping target "CoreGenerateAssemblyInfo" because all output files are up-to-date with respect to the input files.
       CoreCompile:
       Skipping target "CoreCompile" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectory:
       Skipping target "_CopyOutOfDateSourceItemsToOutputDirectory" because all output files are up-to-date with respect to the input files.
       _CopyOutOfDateSourceItemsToOutputDirectoryAlways:
         Copying file from "/home/livia/dafny/Source/DafnyRuntime/DafnyRuntime.cs" to "/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/DafnyRuntime.cs".
       GenerateBuildDependencyFile:
       Skipping target "GenerateBuildDependencyFile" because all output files are up-to-date with respect to the input files.
       GenerateBuildRuntimeConfigurationFiles:
       Skipping target "GenerateBuildRuntimeConfigurationFiles" because all output files are up-to-date with respect to the input files.
       CopyFilesToOutputDirectory:
         IntegrationTests -> /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/IntegrationTests.dll
     1>Done Building Project "/home/livia/dafny/Source/IntegrationTests/IntegrationTests.csproj" (default targets).
     1>BuildProject:
         Build completed.
         
Test run for /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/IntegrationTests.dll (.NETCoreApp,Version=v6.0)
Microsoft (R) Test Execution Command Line Tool Version 17.3.1 (x64)
Copyright (c) Microsoft Corporation.  All rights reserved.

Starting test execution, please wait...
A total of 1 test files matched the specified pattern.
[xUnit.net 00:00:47.35]     allocated1/dafny0/BitvectorsMore.dfy [FAIL]
  Failed allocated1/dafny0/BitvectorsMore.dfy [18 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/allocated1/dafny0/BitvectorsMore.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny0/Output/BitvectorsMore.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
 BitvectorsMore.dfy(13,9): Error: possible division by zero
 BitvectorsMore.dfy(17,13): Error: possible division by zero
 BitvectorsMore.dfy(21,13): Error: possible division by zero
 BitvectorsMore.dfy(25,13): Error: possible division by zero
 BitvectorsMore.dfy(30,15): Error: possible division by zero
 BitvectorsMore.dfy(32,15): Error: possible division by zero
 BitvectorsMore.dfy(104,37): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(105,35): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(105,38): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(107,34): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(107,37): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(115,42): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(116,39): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(116,42): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(124,28): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(124,31): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(125,28): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(125,31): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
-BitvectorsMore.dfy(135,24): Error: shift amount must not exceed the width of the result (32)
 BitvectorsMore.dfy(135,27): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv6
 BitvectorsMore.dfy(136,24): Error: shift amount must not exceed the width of the result (32)
 BitvectorsMore.dfy(136,27): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv6
+BitvectorsMore.dfy(137,24): Error: shift amount must not exceed the width of the result (32)
 BitvectorsMore.dfy(137,27): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv6
 BitvectorsMore.dfy(146,35): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv3
 BitvectorsMore.dfy(147,35): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv3
 BitvectorsMore.dfy(148,35): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv3
 BitvectorsMore.dfy(157,26): Error: shift amount must not exceed the width of the result (2)
 BitvectorsMore.dfy(157,29): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv2
 BitvectorsMore.dfy(158,26): Error: shift amount must not exceed the width of the result (2)
 BitvectorsMore.dfy(158,29): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv2
 BitvectorsMore.dfy(159,29): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv2
 BitvectorsMore.dfy(168,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(169,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(170,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(171,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(193,26): Error: shift amount must not exceed the width of the result (5)
 BitvectorsMore.dfy(194,26): Error: shift amount must not exceed the width of the result (5)
 
 Dafny program verifier finished with 9 verified, 37 errors
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /verifyAllModules /allocated:1 /print:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny0/Output/BitvectorsMore.dfy.tmp.print /env:0 TestFiles/LitTests/LitTest/allocated1/dafny0/BitvectorsMore.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny0/Output/BitvectorsMore.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/allocated1/dafny0/BitvectorsMore.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny0/Output/BitvectorsMore.dfy.tmp
 Previous command results:
 Output:
 BitvectorsMore.dfy(13,9): Error: possible division by zero
 BitvectorsMore.dfy(17,13): Error: possible division by zero
 BitvectorsMore.dfy(21,13): Error: possible division by zero
 BitvectorsMore.dfy(25,13): Error: possible division by zero
 BitvectorsMore.dfy(30,15): Error: possible division by zero
 BitvectorsMore.dfy(32,15): Error: possible division by zero
 BitvectorsMore.dfy(104,37): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(105,35): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(105,38): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(107,34): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(107,37): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(115,42): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(116,39): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(116,42): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(124,28): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(124,31): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(125,28): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(125,31): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(135,27): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv6
 BitvectorsMore.dfy(136,24): Error: shift amount must not exceed the width of the result (32)
 BitvectorsMore.dfy(136,27): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv6
 BitvectorsMore.dfy(137,24): Error: shift amount must not exceed the width of the result (32)
 BitvectorsMore.dfy(137,27): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv6
 BitvectorsMore.dfy(146,35): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv3
 BitvectorsMore.dfy(147,35): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv3
 BitvectorsMore.dfy(148,35): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv3
 BitvectorsMore.dfy(157,26): Error: shift amount must not exceed the width of the result (2)
 BitvectorsMore.dfy(157,29): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv2
 BitvectorsMore.dfy(158,26): Error: shift amount must not exceed the width of the result (2)
 BitvectorsMore.dfy(158,29): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv2
 BitvectorsMore.dfy(159,29): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv2
 BitvectorsMore.dfy(168,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(169,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(170,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(171,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(193,26): Error: shift amount must not exceed the width of the result (5)
 BitvectorsMore.dfy(194,26): Error: shift amount must not exceed the width of the result (5)
 
 Dafny program verifier finished with 9 verified, 37 errors
 
 Error:
 


[xUnit.net 00:02:10.48]     allocated1/dafny0/Fuel.dfy [FAIL]
  Failed allocated1/dafny0/Fuel.dfy [32 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/allocated1/dafny0/Fuel.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny0/Output/Fuel.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
 Fuel.dfy(3,8): Error: the included file Fuel.dfy contains error(s)
 Fuel.dfy(129,8): Error: Fuel can only increase within a given scope.
 Fuel.dfy(407,8): Error: Fuel can only increase within a given scope.
 Fuel.dfy(17,22): Error: assertion might not hold
 Fuel.dfy(65,27): Error: assertion might not hold
 Fuel.dfy(69,27): Error: assertion might not hold
 Fuel.dfy(92,22): Error: assertion might not hold
 Fuel.dfy(93,23): Error: assertion might not hold
 Fuel.dfy(94,22): Error: assertion might not hold
 Fuel.dfy(120,22): Error: assertion might not hold
 Fuel.dfy(121,23): Error: assertion might not hold
 Fuel.dfy(122,22): Error: assertion might not hold
 Fuel.dfy(132,26): Error: assertion might not hold
 Fuel.dfy(133,26): Error: assertion might not hold
 Fuel.dfy(157,22): Error: assertion might not hold
 Fuel.dfy(200,55): Error: assertion might not hold
 Fuel.dfy(245,22): Error: assertion might not hold
 Fuel.dfy(247,22): Error: assertion might not hold
 Fuel.dfy(280,26): Error: assertion might not hold
 Fuel.dfy(335,26): Error: function precondition might not hold
 Fuel.dfy(324,21): Related location
-Fuel.dfy(312,43): Related location
-Fuel.dfy(335,26): Error: function precondition might not hold
-Fuel.dfy(324,21): Related location
 Fuel.dfy(312,58): Related location
-Fuel.dfy(335,26): Error: function precondition might not hold
-Fuel.dfy(324,21): Related location
-Fuel.dfy(313,41): Related location
-Fuel.dfy(335,26): Error: function precondition might not hold
-Fuel.dfy(324,21): Related location
-Fuel.dfy(314,46): Related location
-Fuel.dfy(335,26): Error: function precondition might not hold
-Fuel.dfy(324,21): Related location
-Fuel.dfy(314,72): Related location
-Fuel.dfy(335,26): Error: function precondition might not hold
-Fuel.dfy(324,21): Related location
-Fuel.dfy(314,93): Related location
 Fuel.dfy(335,49): Error: destructor 't' can only be applied to datatype values constructed by 'VTuple'
 Fuel.dfy(335,50): Error: index out of range
 Fuel.dfy(336,38): Error: index out of range
 Fuel.dfy(336,42): Error: destructor 'u' can only be applied to datatype values constructed by 'VUint64'
+Fuel.dfy(336,45): Error: function precondition might not hold
+Fuel.dfy(329,21): Related location
+Fuel.dfy(312,58): Related location
+Fuel.dfy(336,45): Error: function precondition might not hold
+Fuel.dfy(329,21): Related location
+Fuel.dfy(311,43): Related location
+Fuel.dfy(336,45): Error: function precondition might not hold
+Fuel.dfy(329,21): Related location
+Fuel.dfy(313,41): Related location
+Fuel.dfy(336,45): Error: function precondition might not hold
+Fuel.dfy(329,21): Related location
+Fuel.dfy(314,93): Related location
+Fuel.dfy(336,71): Error: index out of range
 Fuel.dfy(397,22): Error: assertion might not hold
 Fuel.dfy(398,22): Error: assertion might not hold
 Fuel.dfy(399,23): Error: assertion might not hold
 Fuel.dfy(435,22): Error: assertion might not hold
 Fuel.dfy(436,22): Error: assertion might not hold
 Fuel.dfy(437,23): Error: assertion might not hold
 
 Dafny program verifier finished with 30 verified, 32 errors
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /verifyAllModules /allocated:1 /compile:0 /print:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny0/Output/Fuel.dfy.tmp.print /dprint:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny0/Output/Fuel.dfy.tmp.dprint /autoTriggers:0 /optimizeResolution:0 /errorLimit:10 TestFiles/LitTests/LitTest/allocated1/dafny0/Fuel.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny0/Output/Fuel.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/allocated1/dafny0/Fuel.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny0/Output/Fuel.dfy.tmp
 Previous command results:
 Output:
 Fuel.dfy(3,8): Error: the included file Fuel.dfy contains error(s)
 Fuel.dfy(129,8): Error: Fuel can only increase within a given scope.
 Fuel.dfy(407,8): Error: Fuel can only increase within a given scope.
 Fuel.dfy(17,22): Error: assertion might not hold
 Fuel.dfy(65,27): Error: assertion might not hold
 Fuel.dfy(69,27): Error: assertion might not hold
 Fuel.dfy(92,22): Error: assertion might not hold
 Fuel.dfy(93,23): Error: assertion might not hold
 Fuel.dfy(94,22): Error: assertion might not hold
 Fuel.dfy(120,22): Error: assertion might not hold
 Fuel.dfy(121,23): Error: assertion might not hold
 Fuel.dfy(122,22): Error: assertion might not hold
 Fuel.dfy(132,26): Error: assertion might not hold
 Fuel.dfy(133,26): Error: assertion might not hold
 Fuel.dfy(157,22): Error: assertion might not hold
 Fuel.dfy(200,55): Error: assertion might not hold
 Fuel.dfy(245,22): Error: assertion might not hold
 Fuel.dfy(247,22): Error: assertion might not hold
 Fuel.dfy(280,26): Error: assertion might not hold
 Fuel.dfy(335,26): Error: function precondition might not hold
 Fuel.dfy(324,21): Related location
 Fuel.dfy(312,58): Related location
 Fuel.dfy(335,49): Error: destructor 't' can only be applied to datatype values constructed by 'VTuple'
 Fuel.dfy(335,50): Error: index out of range
 Fuel.dfy(336,38): Error: index out of range
 Fuel.dfy(336,42): Error: destructor 'u' can only be applied to datatype values constructed by 'VUint64'
 Fuel.dfy(336,45): Error: function precondition might not hold
 Fuel.dfy(329,21): Related location
 Fuel.dfy(312,58): Related location
 Fuel.dfy(336,45): Error: function precondition might not hold
 Fuel.dfy(329,21): Related location
 Fuel.dfy(311,43): Related location
 Fuel.dfy(336,45): Error: function precondition might not hold
 Fuel.dfy(329,21): Related location
 Fuel.dfy(313,41): Related location
 Fuel.dfy(336,45): Error: function precondition might not hold
 Fuel.dfy(329,21): Related location
 Fuel.dfy(314,93): Related location
 Fuel.dfy(336,71): Error: index out of range
 Fuel.dfy(397,22): Error: assertion might not hold
 Fuel.dfy(398,22): Error: assertion might not hold
 Fuel.dfy(399,23): Error: assertion might not hold
 Fuel.dfy(435,22): Error: assertion might not hold
 Fuel.dfy(436,22): Error: assertion might not hold
 Fuel.dfy(437,23): Error: assertion might not hold
 
 Dafny program verifier finished with 30 verified, 32 errors
 
 Error:
 


[xUnit.net 00:02:38.02]     allocated1/dafny0/Inverses.dfy [FAIL]
  Failed allocated1/dafny0/Inverses.dfy [27 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/allocated1/dafny0/Inverses.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny0/Output/Inverses.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
 Inverses.dfy(70,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(67,10): Related location: This is the postcondition that might not hold.
 Inverses.dfy(67,66): Related location
 Inverses.dfy(82,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(79,10): Related location: This is the postcondition that might not hold.
 Inverses.dfy(79,66): Related location
+Inverses.dfy(94,2): Error: A postcondition might not hold on this return path.
+Inverses.dfy(91,10): Related location: This is the postcondition that might not hold.
+Inverses.dfy(91,66): Related location
+Inverses.dfy(104,2): Error: A postcondition might not hold on this return path.
+Inverses.dfy(101,10): Related location: This is the postcondition that might not hold.
+Inverses.dfy(101,66): Related location
 Inverses.dfy(193,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(191,15): Related location: This is the postcondition that might not hold.
 
-Dafny program verifier finished with 31 verified, 3 errors
+Dafny program verifier finished with 29 verified, 5 errors
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /verifyAllModules /allocated:1 /compile:0 /print:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny0/Output/Inverses.dfy.tmp.print /dprint:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny0/Output/Inverses.dfy.tmp.dprint TestFiles/LitTests/LitTest/allocated1/dafny0/Inverses.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny0/Output/Inverses.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/allocated1/dafny0/Inverses.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny0/Output/Inverses.dfy.tmp
 Previous command results:
 Output:
 Inverses.dfy(70,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(67,10): Related location: This is the postcondition that might not hold.
 Inverses.dfy(67,66): Related location
 Inverses.dfy(82,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(79,10): Related location: This is the postcondition that might not hold.
 Inverses.dfy(79,66): Related location
 Inverses.dfy(94,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(91,10): Related location: This is the postcondition that might not hold.
 Inverses.dfy(91,66): Related location
 Inverses.dfy(104,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(101,10): Related location: This is the postcondition that might not hold.
 Inverses.dfy(101,66): Related location
 Inverses.dfy(193,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(191,15): Related location: This is the postcondition that might not hold.
 
 Dafny program verifier finished with 29 verified, 5 errors
 
 Error:
 


[xUnit.net 00:11:01.68]     allocated1/dafny1/SchorrWaite.dfy [FAIL]
  Failed allocated1/dafny1/SchorrWaite.dfy [5 m 34 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (4): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /allocated:1 /compile:0 /dprint:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny1/Output/SchorrWaite.dfy.tmp.dprint /autoTriggers:0 TestFiles/LitTests/LitTest/allocated1/dafny1/SchorrWaite.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny1/Output/SchorrWaite.dfy.tmp
Output:
SchorrWaite.dfy(168,9): Verification of 'Main.SchorrWaite (correctness)' timed out after 300 seconds

Dafny program verifier finished with 9 verified, 0 errors, 1 time out

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /allocated:1 /compile:0 /dprint:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny1/Output/SchorrWaite.dfy.tmp.dprint /autoTriggers:0 TestFiles/LitTests/LitTest/allocated1/dafny1/SchorrWaite.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/allocated1/dafny1/Output/SchorrWaite.dfy.tmp
 Previous command results:


[xUnit.net 00:14:41.59]     comp/GoModule.dfy [FAIL]
  Failed comp/GoModule.dfy [15 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/comp/GoModule.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/comp/Output/GoModule.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
 
 Dafny program verifier finished with 2 verified, 0 errors
 The address http://localhost:8080/default.htm?year=1915&month=august&day=29
 has the following parts:
 host: localhost:8080
 pathname: /default.htm
 search: year=1915&month=august&day=29
-Parse error: parse "http://localhost:8080/default.htm%": invalid URL escape "%"
+Parse error: parse http://localhost:8080/default.htm%: invalid URL escape "%"
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:3 /spillTargetCode:2 TestFiles/LitTests/LitTest/comp/GoModule.dfy /compileTarget:go > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/comp/Output/GoModule.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/comp/GoModule.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/comp/Output/GoModule.dfy.tmp
 Previous command results:
 Output:
 
 Dafny program verifier finished with 2 verified, 0 errors
 The address http://localhost:8080/default.htm?year=1915&month=august&day=29
 has the following parts:
 host: localhost:8080
 pathname: /default.htm
 search: year=1915&month=august&day=29
 Parse error: parse http://localhost:8080/default.htm%: invalid URL escape "%"
 
 Error:
 


[xUnit.net 00:24:39.54]     concurrency/12-MutexLifetime-long.dfy [SKIP]
  Skipped concurrency/12-MutexLifetime-long.dfy [1 ms]
[xUnit.net 00:28:40.58]     concurrency/09-CounterNoStateMachine.dfy [FAIL]
  Failed concurrency/09-CounterNoStateMachine.dfy [7 m 1 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (4): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 TestFiles/LitTests/LitTest/concurrency/09-CounterNoStateMachine.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/concurrency/Output/09-CounterNoStateMachine.dfy.tmp
Output:
09-CounterNoStateMachine.dfy(693,7): Verification of 'Incrementer (correctness)' timed out after 300 seconds

Dafny program verifier finished with 164 verified, 0 errors, 1 time out

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 TestFiles/LitTests/LitTest/concurrency/09-CounterNoStateMachine.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/concurrency/Output/09-CounterNoStateMachine.dfy.tmp
 Previous command results:


[xUnit.net 00:29:05.23]     concurrency/10-SequenceInvariant.dfy [FAIL]
  Failed concurrency/10-SequenceInvariant.dfy [7 m 22 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (4): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 TestFiles/LitTests/LitTest/concurrency/10-SequenceInvariant.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/concurrency/Output/10-SequenceInvariant.dfy.tmp
Output:
10-SequenceInvariant.dfy(617,7): Verification of 'Incrementer (correctness)' timed out after 300 seconds

Dafny program verifier finished with 165 verified, 0 errors, 1 time out

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 TestFiles/LitTests/LitTest/concurrency/10-SequenceInvariant.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/concurrency/Output/10-SequenceInvariant.dfy.tmp
 Previous command results:


[xUnit.net 00:29:10.43]     dafny0/AutoContracts.dfy [FAIL]
  Failed dafny0/AutoContracts.dfy [29 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/dafny0/AutoContracts.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/AutoContracts.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
 // AutoContracts.dfy
 
 /*
 module _System {
   /* CALL GRAPH for module _System:
    * SCC at height 1:
    *   RotateRight
    * SCC at height 1:
    *   RotateLeft
    * SCC at height 0:
    *   nat
    */
   type string(==,0) = seq<char>
 
   type {:axiom} nat(==,0) = x: int
     | 0 <= x
 
   trait {:compile false} object { }
   /*-- non-null type
   type {:axiom} object(==) = c: object? | c != null /*special witness*/
   */
 
   class {:compile false} array<arg> {
     var Length: int  // immutable
   }
   /*-- non-null type
   type {:axiom} array(==)<arg> = c: array?<arg> | c != null /*special witness*/
   */
 
   class {:compile false} /*_#Func1*/ -T0 ~> +R {
     function requires(x0: T0): bool
       reads reads(x0)
 
     function reads(x0: T0): set<object?>
       reads reads(x0)
   }
 
   type {:compile false} /*_#PartialFunc1*/ -T0 --> +R = f: T0 ~> R
     | forall x0: T0 :: f.reads(x0) == {}
     /*special witness*/
 
   type {:compile false} /*_#TotalFunc1*/ -T0 -> +R = f: T0 --> R
     | forall x0: T0 :: f.requires(x0)
     /*special witness*/
 
   class {:compile false} /*_#Func0*/ () ~> +R {
     function requires(): bool
       reads reads()
 
     function reads(): set<object?>
       reads reads()
   }
 
   type {:compile false} /*_#PartialFunc0*/ () --> +R = f: () ~> R
     | f.reads() == {}
     /*special witness*/
 
   type {:compile false} /*_#TotalFunc0*/ () -> +R = f: () --> R
     | f.requires()
     /*special witness*/
 
   datatype {:compile false} /*_tuple#2*/ (+T0, +T1) = _#Make2(0: T0, 1: T1)
 
   type bool { }
 
   type int { }
 
   type real {
     var Floor: int  // immutable
   }
 
   type ORDINAL {
     var IsLimit: bool  // immutable
     var IsSucc: bool  // immutable
     var Offset: int  // immutable
     var IsNat: bool  // immutable
   }
 
   type _bv {
     function method RotateLeft(w: nat): selftype
 
     function method RotateRight(w: nat): selftype
   }
 
   type map<T, U> {
     var Keys: set<T>  // immutable
     var Values: set<U>  // immutable
     var Items: set<(T, U)>  // immutable
   }
 
   type imap<T, U> {
     var Keys: iset<T>  // immutable
     var Values: iset<U>  // immutable
     var Items: iset<(T, U)>  // immutable
   }
 
   datatype {:compile false} /*_tuple#0*/ () = _#Make0
 }
 // bitvector types in use:
 */
 
 /* CALL GRAPH for module _module:
  */
 
 module OneModule {
   /* CALL GRAPH for module OneModule:
    * SCC at height 2:
    *   C.NoBody
    * SCC at height 2:
    *   C.TL
    * SCC at height 2:
    *   C.L
    * SCC at height 2:
    *   C.Query
    * SCC at height 2:
    *   C.Mutating
    * SCC at height 2:
    *   C.P
    * SCC at height 2:
    *   C._ctor
    * SCC at height 2:
    *   C.F
    * SCC at height 1:
    *   C.Valid
    * SCC at height 0:
    *   D.Valid
    * SCC at height 0:
    *   nat
    */
   class {:autocontracts} D {
     ghost var Repr: set<object?>
 
     predicate Valid()
       reads this, Repr
       ensures Valid() ==> this in Repr
       decreases Repr + {this}
     {
       this in Repr &&
       null !in Repr &&
       true
     }
   }
   /*-- non-null type
   type {:axiom} D(==) = c: D? | c != null /*special witness*/
   */
 
   class {:autocontracts} C {
     var data: int
     var anotherC: C?
     var dd: D?
     var {:autocontracts false} ee: D?
     var arr: array?<C?>
 
     predicate Valid()
       reads this, Repr
       ensures Valid() ==> this in Repr
       decreases Repr + {this}
     {
       this in Repr &&
       null !in Repr &&
       (anotherC != null ==>
         anotherC in Repr &&
         anotherC.Repr <= Repr &&
         this !in anotherC.Repr &&
         anotherC.Valid()) &&
       (dd != null ==>
         dd in Repr &&
         dd.Repr <= Repr &&
         this !in dd.Repr &&
         dd.Valid()) &&
       (arr != null ==>
         arr in Repr) &&
       0 <= data < 100
     }
 
     constructor ()
       ensures Valid()
       ensures fresh(Repr)
     {
       data := 0;
       new;
       Repr := {this};
       if anotherC != null && !(anotherC in Repr && anotherC.Repr <= Repr) {
         Repr := Repr + {anotherC} + anotherC.Repr;
       }
       if dd != null && !(dd in Repr && dd.Repr <= Repr) {
         Repr := Repr + {dd} + dd.Repr;
       }
       if arr != null && !(arr in Repr) {
         Repr := Repr + {arr};
       }
     }
 
     method Mutating()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
       ensures old(data) <= data
     {
       if anotherC != null && !(anotherC in Repr && anotherC.Repr <= Repr) {
         Repr := Repr + {anotherC} + anotherC.Repr;
       }
       if dd != null && !(dd in Repr && dd.Repr <= Repr) {
         Repr := Repr + {dd} + dd.Repr;
       }
       if arr != null && !(arr in Repr) {
         Repr := Repr + {arr};
       }
     }
 
     method Query() returns (d: int)
       requires Valid()
       ensures d == data
     {
       d := data;
     }
 
     function F(): nat
       requires Valid()
       reads Repr
       decreases Repr
     {
       data
     }
 
     predicate P()
       requires Valid()
       reads Repr
       decreases Repr
     {
       data < 20
     }
 
     lemma /*{:_induction this}*/ L()
       requires Valid()
       ensures data < 100
     {
     }
 
     twostate lemma /*{:_induction this}*/ TL()
       requires old(Valid())
       ensures old(data) <= data
     {
     }
 
     method NoBody()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
 
     ghost var Repr: set<object?>
   }
   /*-- non-null type
   type {:axiom} C(==) = c: C? | c != null /*special witness*/
   */
 }
 
 module N0 {
   /* CALL GRAPH for module N0:
    * SCC at height 1:
    *   C.B
    * SCC at height 1:
    *   C.A
    * SCC at height 1:
    *   C.C
    * SCC at height 1:
    *   C.M
    * SCC at height 1:
    *   C.L
    * SCC at height 1:
    *   C.K
    * SCC at height 1:
    *   C.Z
    * SCC at height 1:
    *   C.Y
    * SCC at height 1:
    *   C.X
    * SCC at height 0:
    *   C.Valid
    */
   class {:autocontracts} C {
     constructor X()
       ensures Valid()
       ensures fresh(Repr)
 
     constructor Y()
       ensures Valid()
       ensures fresh(Repr)
 
     constructor Z()
       ensures Valid()
       ensures fresh(Repr)
     {
       new;
       Repr := {this};
     }
 
     method A()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
 
     method B()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
 
     method C()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
     {
     }
 
     predicate Valid()
       reads this, Repr
       ensures Valid() ==> this in Repr
       decreases Repr + {this}
     {
       this in Repr &&
       null !in Repr &&
       true
     }
 
     ghost var Repr: set<object?>
 
     method {:autocontracts false} K()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
 
     method {:autocontracts false} L()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
 
     method {:autocontracts false} M()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
     {
     }
   }
   /*-- non-null type
   type {:axiom} C(==) = c: C? | c != null /*special witness*/
   */
 }
 
 module N1 refines N0 {
   /* CALL GRAPH for module N1:
    * SCC at height 1:
    *   C.M
    * SCC at height 1:
    *   C.L
    * SCC at height 1:
    *   C.K
    * SCC at height 1:
    *   C.C
    * SCC at height 1:
    *   C.B
    * SCC at height 1:
    *   C.A
    * SCC at height 1:
    *   C.Z
    * SCC at height 1:
    *   C.Y
    * SCC at height 1:
    *   C.X
    * SCC at height 0:
    *   C.Valid
    */
   class {:autocontracts} C ...  {
     constructor X()
       ensures Valid()
       ensures fresh(Repr)
 
     constructor Y()
       ensures Valid()
       ensures fresh(Repr)
     {
     }
 
     constructor Z()
       ensures Valid()
       ensures fresh(Repr)
     {
       new;
       Repr := {this};
     }
 
     method A()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
 
     method B()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
     {
     }
 
     method C()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
     {
     }
 
     method {:autocontracts false} K()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
 
     method {:autocontracts false} L()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
     {
     }
 
     method {:autocontracts false} M()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
     {
     }
 
     predicate Valid()
       reads this, Repr
       ensures Valid() ==> this in Repr
       decreases Repr + {this}
     {
       this in Repr &&
       null !in Repr &&
       true
     }
 
     ghost var Repr: set<object?>
   }
   /*-- non-null type
   type {:axiom} C(==) = c: C? | c != null /*special witness*/
   */
 }
 
 module N2 refines N1 {
   /* CALL GRAPH for module N2:
    * SCC at height 1:
    *   C.M
    * SCC at height 1:
    *   C.L
    * SCC at height 1:
    *   C.K
    * SCC at height 1:
    *   C.C
    * SCC at height 1:
    *   C.B
    * SCC at height 1:
    *   C.A
    * SCC at height 1:
    *   C.Z
    * SCC at height 1:
    *   C.Y
    * SCC at height 1:
    *   C.X
    * SCC at height 0:
    *   C.Valid
    */
   class {:autocontracts} C ...  {
     constructor X()
       ensures Valid()
       ensures fresh(Repr)
 
     constructor Y()
       ensures Valid()
       ensures fresh(Repr)
     {
     }
 
     constructor Z()
       ensures Valid()
       ensures fresh(Repr)
     {
       new;
       Repr := {this};
     }
 
     method A()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
 
     method B()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
     {
     }
 
     method C()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
     {
     }
 
     method {:autocontracts false} K()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
 
     method {:autocontracts false} L()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
     {
     }
 
     method {:autocontracts false} M()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
     {
     }
 
     predicate Valid()
       reads this, Repr
       ensures Valid() ==> this in Repr
       decreases Repr + {this}
     {
       this in Repr &&
       null !in Repr &&
       true
     }
 
     ghost var Repr: set<object?>
   }
   /*-- non-null type
   type {:axiom} C(==) = c: C? | c != null /*special witness*/
   */
 }
 AutoContracts.dfy(17,4): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(17,4): Related location: This is the postcondition that might not hold.
 AutoContracts.dfy(12,14): Related location
 AutoContracts.dfy(17,4): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(17,4): Related location: This is the postcondition that might not hold.
+AutoContracts.dfy(12,14): Related location
 AutoContracts.dfy(17,4): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(17,4): Related location: This is the postcondition that might not hold.
 AutoContracts.dfy(12,14): Related location
 AutoContracts.dfy(17,4): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(17,4): Related location: This is the postcondition that might not hold.
 AutoContracts.dfy(12,14): Related location
+AutoContracts.dfy(5,25): Related location
 AutoContracts.dfy(17,4): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(17,4): Related location: This is the postcondition that might not hold.
-AutoContracts.dfy(12,14): Related location
-AutoContracts.dfy(5,25): Related location
 AutoContracts.dfy(50,4): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(49,24): Related location: This is the postcondition that might not hold.
 AutoContracts.dfy(79,21): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(60,16): Related location: This is the postcondition that might not hold.
 AutoContracts.dfy[N1](65,14): Related location
 AutoContracts.dfy(79,21): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(60,16): Related location: This is the postcondition that might not hold.
 AutoContracts.dfy[N1](65,14): Related location
 AutoContracts.dfy(79,21): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(60,16): Related location: This is the postcondition that might not hold.
 
 Dafny program verifier finished with 37 verified, 9 errors
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /env:0 /print:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/AutoContracts.dfy.tmp.print /rprint:- TestFiles/LitTests/LitTest/dafny0/AutoContracts.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/AutoContracts.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/dafny0/AutoContracts.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/AutoContracts.dfy.tmp
 Previous command results:
 Output:
 // AutoContracts.dfy
 
 /*
 module _System {
   /* CALL GRAPH for module _System:
    * SCC at height 1:
    *   RotateRight
    * SCC at height 1:
    *   RotateLeft
    * SCC at height 0:
    *   nat
    */
   type string(==,0) = seq<char>
 
   type {:axiom} nat(==,0) = x: int
     | 0 <= x
 
   trait {:compile false} object { }
   /*-- non-null type
   type {:axiom} object(==) = c: object? | c != null /*special witness*/
   */
 
   class {:compile false} array<arg> {
     var Length: int  // immutable
   }
   /*-- non-null type
   type {:axiom} array(==)<arg> = c: array?<arg> | c != null /*special witness*/
   */
 
   class {:compile false} /*_#Func1*/ -T0 ~> +R {
     function requires(x0: T0): bool
       reads reads(x0)
 
     function reads(x0: T0): set<object?>
       reads reads(x0)
   }
 
   type {:compile false} /*_#PartialFunc1*/ -T0 --> +R = f: T0 ~> R
     | forall x0: T0 :: f.reads(x0) == {}
     /*special witness*/
 
   type {:compile false} /*_#TotalFunc1*/ -T0 -> +R = f: T0 --> R
     | forall x0: T0 :: f.requires(x0)
     /*special witness*/
 
   class {:compile false} /*_#Func0*/ () ~> +R {
     function requires(): bool
       reads reads()
 
     function reads(): set<object?>
       reads reads()
   }
 
   type {:compile false} /*_#PartialFunc0*/ () --> +R = f: () ~> R
     | f.reads() == {}
     /*special witness*/
 
   type {:compile false} /*_#TotalFunc0*/ () -> +R = f: () --> R
     | f.requires()
     /*special witness*/
 
   datatype {:compile false} /*_tuple#2*/ (+T0, +T1) = _#Make2(0: T0, 1: T1)
 
   type bool { }
 
   type int { }
 
   type real {
     var Floor: int  // immutable
   }
 
   type ORDINAL {
     var IsLimit: bool  // immutable
     var IsSucc: bool  // immutable
     var Offset: int  // immutable
     var IsNat: bool  // immutable
   }
 
   type _bv {
     function method RotateLeft(w: nat): selftype
 
     function method RotateRight(w: nat): selftype
   }
 
   type map<T, U> {
     var Keys: set<T>  // immutable
     var Values: set<U>  // immutable
     var Items: set<(T, U)>  // immutable
   }
 
   type imap<T, U> {
     var Keys: iset<T>  // immutable
     var Values: iset<U>  // immutable
     var Items: iset<(T, U)>  // immutable
   }
 
   datatype {:compile false} /*_tuple#0*/ () = _#Make0
 }
 // bitvector types in use:
 */
 
 /* CALL GRAPH for module _module:
  */
 
 module OneModule {
   /* CALL GRAPH for module OneModule:
    * SCC at height 2:
    *   C.NoBody
    * SCC at height 2:
    *   C.TL
    * SCC at height 2:
    *   C.L
    * SCC at height 2:
    *   C.Query
    * SCC at height 2:
    *   C.Mutating
    * SCC at height 2:
    *   C.P
    * SCC at height 2:
    *   C._ctor
    * SCC at height 2:
    *   C.F
    * SCC at height 1:
    *   C.Valid
    * SCC at height 0:
    *   D.Valid
    * SCC at height 0:
    *   nat
    */
   class {:autocontracts} D {
     ghost var Repr: set<object?>
 
     predicate Valid()
       reads this, Repr
       ensures Valid() ==> this in Repr
       decreases Repr + {this}
     {
       this in Repr &&
       null !in Repr &&
       true
     }
   }
   /*-- non-null type
   type {:axiom} D(==) = c: D? | c != null /*special witness*/
   */
 
   class {:autocontracts} C {
     var data: int
     var anotherC: C?
     var dd: D?
     var {:autocontracts false} ee: D?
     var arr: array?<C?>
 
     predicate Valid()
       reads this, Repr
       ensures Valid() ==> this in Repr
       decreases Repr + {this}
     {
       this in Repr &&
       null !in Repr &&
       (anotherC != null ==>
         anotherC in Repr &&
         anotherC.Repr <= Repr &&
         this !in anotherC.Repr &&
         anotherC.Valid()) &&
       (dd != null ==>
         dd in Repr &&
         dd.Repr <= Repr &&
         this !in dd.Repr &&
         dd.Valid()) &&
       (arr != null ==>
         arr in Repr) &&
       0 <= data < 100
     }
 
     constructor ()
       ensures Valid()
       ensures fresh(Repr)
     {
       data := 0;
       new;
       Repr := {this};
       if anotherC != null && !(anotherC in Repr && anotherC.Repr <= Repr) {
         Repr := Repr + {anotherC} + anotherC.Repr;
       }
       if dd != null && !(dd in Repr && dd.Repr <= Repr) {
         Repr := Repr + {dd} + dd.Repr;
       }
       if arr != null && !(arr in Repr) {
         Repr := Repr + {arr};
       }
     }
 
     method Mutating()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
       ensures old(data) <= data
     {
       if anotherC != null && !(anotherC in Repr && anotherC.Repr <= Repr) {
         Repr := Repr + {anotherC} + anotherC.Repr;
       }
       if dd != null && !(dd in Repr && dd.Repr <= Repr) {
         Repr := Repr + {dd} + dd.Repr;
       }
       if arr != null && !(arr in Repr) {
         Repr := Repr + {arr};
       }
     }
 
     method Query() returns (d: int)
       requires Valid()
       ensures d == data
     {
       d := data;
     }
 
     function F(): nat
       requires Valid()
       reads Repr
       decreases Repr
     {
       data
     }
 
     predicate P()
       requires Valid()
       reads Repr
       decreases Repr
     {
       data < 20
     }
 
     lemma /*{:_induction this}*/ L()
       requires Valid()
       ensures data < 100
     {
     }
 
     twostate lemma /*{:_induction this}*/ TL()
       requires old(Valid())
       ensures old(data) <= data
     {
     }
 
     method NoBody()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
 
     ghost var Repr: set<object?>
   }
   /*-- non-null type
   type {:axiom} C(==) = c: C? | c != null /*special witness*/
   */
 }
 
 module N0 {
   /* CALL GRAPH for module N0:
    * SCC at height 1:
    *   C.B
    * SCC at height 1:
    *   C.A
    * SCC at height 1:
    *   C.C
    * SCC at height 1:
    *   C.M
    * SCC at height 1:
    *   C.L
    * SCC at height 1:
    *   C.K
    * SCC at height 1:
    *   C.Z
    * SCC at height 1:
    *   C.Y
    * SCC at height 1:
    *   C.X
    * SCC at height 0:
    *   C.Valid
    */
   class {:autocontracts} C {
     constructor X()
       ensures Valid()
       ensures fresh(Repr)
 
     constructor Y()
       ensures Valid()
       ensures fresh(Repr)
 
     constructor Z()
       ensures Valid()
       ensures fresh(Repr)
     {
       new;
       Repr := {this};
     }
 
     method A()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
 
     method B()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
 
     method C()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
     {
     }
 
     predicate Valid()
       reads this, Repr
       ensures Valid() ==> this in Repr
       decreases Repr + {this}
     {
       this in Repr &&
       null !in Repr &&
       true
     }
 
     ghost var Repr: set<object?>
 
     method {:autocontracts false} K()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
 
     method {:autocontracts false} L()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
 
     method {:autocontracts false} M()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
     {
     }
   }
   /*-- non-null type
   type {:axiom} C(==) = c: C? | c != null /*special witness*/
   */
 }
 
 module N1 refines N0 {
   /* CALL GRAPH for module N1:
    * SCC at height 1:
    *   C.M
    * SCC at height 1:
    *   C.L
    * SCC at height 1:
    *   C.K
    * SCC at height 1:
    *   C.C
    * SCC at height 1:
    *   C.B
    * SCC at height 1:
    *   C.A
    * SCC at height 1:
    *   C.Z
    * SCC at height 1:
    *   C.Y
    * SCC at height 1:
    *   C.X
    * SCC at height 0:
    *   C.Valid
    */
   class {:autocontracts} C ...  {
     constructor X()
       ensures Valid()
       ensures fresh(Repr)
 
     constructor Y()
       ensures Valid()
       ensures fresh(Repr)
     {
     }
 
     constructor Z()
       ensures Valid()
       ensures fresh(Repr)
     {
       new;
       Repr := {this};
     }
 
     method A()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
 
     method B()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
     {
     }
 
     method C()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
     {
     }
 
     method {:autocontracts false} K()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
 
     method {:autocontracts false} L()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
     {
     }
 
     method {:autocontracts false} M()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
     {
     }
 
     predicate Valid()
       reads this, Repr
       ensures Valid() ==> this in Repr
       decreases Repr + {this}
     {
       this in Repr &&
       null !in Repr &&
       true
     }
 
     ghost var Repr: set<object?>
   }
   /*-- non-null type
   type {:axiom} C(==) = c: C? | c != null /*special witness*/
   */
 }
 
 module N2 refines N1 {
   /* CALL GRAPH for module N2:
    * SCC at height 1:
    *   C.M
    * SCC at height 1:
    *   C.L
    * SCC at height 1:
    *   C.K
    * SCC at height 1:
    *   C.C
    * SCC at height 1:
    *   C.B
    * SCC at height 1:
    *   C.A
    * SCC at height 1:
    *   C.Z
    * SCC at height 1:
    *   C.Y
    * SCC at height 1:
    *   C.X
    * SCC at height 0:
    *   C.Valid
    */
   class {:autocontracts} C ...  {
     constructor X()
       ensures Valid()
       ensures fresh(Repr)
 
     constructor Y()
       ensures Valid()
       ensures fresh(Repr)
     {
     }
 
     constructor Z()
       ensures Valid()
       ensures fresh(Repr)
     {
       new;
       Repr := {this};
     }
 
     method A()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
 
     method B()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
     {
     }
 
     method C()
       requires Valid()
       modifies Repr
       ensures Valid()
       ensures fresh(Repr - old(Repr))
     {
     }
 
     method {:autocontracts false} K()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
 
     method {:autocontracts false} L()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
     {
     }
 
     method {:autocontracts false} M()
       requires Valid()
       modifies Repr
       ensures Valid() && fresh(Repr - old(Repr))
     {
     }
 
     predicate Valid()
       reads this, Repr
       ensures Valid() ==> this in Repr
       decreases Repr + {this}
     {
       this in Repr &&
       null !in Repr &&
       true
     }
 
     ghost var Repr: set<object?>
   }
   /*-- non-null type
   type {:axiom} C(==) = c: C? | c != null /*special witness*/
   */
 }
 AutoContracts.dfy(17,4): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(17,4): Related location: This is the postcondition that might not hold.
 AutoContracts.dfy(12,14): Related location
 AutoContracts.dfy(17,4): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(17,4): Related location: This is the postcondition that might not hold.
 AutoContracts.dfy(12,14): Related location
 AutoContracts.dfy(17,4): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(17,4): Related location: This is the postcondition that might not hold.
 AutoContracts.dfy(12,14): Related location
 AutoContracts.dfy(17,4): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(17,4): Related location: This is the postcondition that might not hold.
 AutoContracts.dfy(12,14): Related location
 AutoContracts.dfy(5,25): Related location
 AutoContracts.dfy(17,4): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(17,4): Related location: This is the postcondition that might not hold.
 AutoContracts.dfy(50,4): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(49,24): Related location: This is the postcondition that might not hold.
 AutoContracts.dfy(79,21): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(60,16): Related location: This is the postcondition that might not hold.
 AutoContracts.dfy[N1](65,14): Related location
 AutoContracts.dfy(79,21): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(60,16): Related location: This is the postcondition that might not hold.
 AutoContracts.dfy[N1](65,14): Related location
 AutoContracts.dfy(79,21): Error: A postcondition might not hold on this return path.
 AutoContracts.dfy(60,16): Related location: This is the postcondition that might not hold.
 
 Dafny program verifier finished with 37 verified, 9 errors
 
 Error:
 


[xUnit.net 00:29:19.82]     concurrency/11-MutexGuard2.dfy [FAIL]
  Failed concurrency/11-MutexGuard2.dfy [7 m 32 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (4): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /proverOpt:O:smt.qi.eager_threshold=30 TestFiles/LitTests/LitTest/concurrency/11-MutexGuard2.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/concurrency/Output/11-MutexGuard2.dfy.tmp
Output:
11-MutexGuard2.dfy(652,7): Verification of 'SetData (correctness)' timed out after 300 seconds

Dafny program verifier finished with 154 verified, 0 errors, 1 time out

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /proverOpt:O:smt.qi.eager_threshold=30 TestFiles/LitTests/LitTest/concurrency/11-MutexGuard2.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/concurrency/Output/11-MutexGuard2.dfy.tmp
 Previous command results:


[xUnit.net 00:29:42.23]     dafny0/BitvectorsMore.dfy [FAIL]
  Failed dafny0/BitvectorsMore.dfy [17 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/dafny0/BitvectorsMore.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/BitvectorsMore.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
 // BitvectorsMore.dfy
 
 /*
 module _System {
   /* CALL GRAPH for module _System:
    * SCC at height 1:
    *   RotateRight
    * SCC at height 1:
    *   RotateLeft
    * SCC at height 0:
    *   nat
    */
   type string(==,0) = seq<char>
 
   type {:axiom} nat(==,0) = x: int
     | 0 <= x
 
   trait {:compile false} object { }
   /*-- non-null type
   type {:axiom} object(==) = c: object? | c != null /*special witness*/
   */
 
   class {:compile false} array<arg> {
     var Length: int  // immutable
   }
   /*-- non-null type
   type {:axiom} array(==)<arg> = c: array?<arg> | c != null /*special witness*/
   */
 
   class {:compile false} /*_#Func1*/ -T0 ~> +R {
     function requires(x0: T0): bool
       reads reads(x0)
 
     function reads(x0: T0): set<object?>
       reads reads(x0)
   }
 
   type {:compile false} /*_#PartialFunc1*/ -T0 --> +R = f: T0 ~> R
     | forall x0: T0 :: f.reads(x0) == {}
     /*special witness*/
 
   type {:compile false} /*_#TotalFunc1*/ -T0 -> +R = f: T0 --> R
     | forall x0: T0 :: f.requires(x0)
     /*special witness*/
 
   class {:compile false} /*_#Func0*/ () ~> +R {
     function requires(): bool
       reads reads()
 
     function reads(): set<object?>
       reads reads()
   }
 
   type {:compile false} /*_#PartialFunc0*/ () --> +R = f: () ~> R
     | f.reads() == {}
     /*special witness*/
 
   type {:compile false} /*_#TotalFunc0*/ () -> +R = f: () --> R
     | f.requires()
     /*special witness*/
 
   class {:compile false} /*_#Func11*/ (-T0, -T1, -T2, -T3, -T4, -T5, -T6, -T7, -T8, -T9, -T10) ~> +R {
     function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9, x10: T10): bool
       reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10)
 
     function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9, x10: T10): set<object?>
       reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10)
   }
 
   type {:compile false} /*_#PartialFunc11*/ (-T0, -T1, -T2, -T3, -T4, -T5, -T6, -T7, -T8, -T9, -T10) --> +R = f: (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) ~> R
     | forall x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9, x10: T10 :: f.reads(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10) == {}
     /*special witness*/
 
   type {:compile false} /*_#TotalFunc11*/ (-T0, -T1, -T2, -T3, -T4, -T5, -T6, -T7, -T8, -T9, -T10) -> +R = f: (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) --> R
     | forall x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9, x10: T10 :: f.requires(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10)
     /*special witness*/
 
   datatype {:compile false} /*_tuple#2*/ (+T0, +T1) = _#Make2(0: T0, 1: T1)
 
   type bool { }
 
   type int { }
 
   type real {
     var Floor: int  // immutable
   }
 
   type ORDINAL {
     var IsLimit: bool  // immutable
     var IsSucc: bool  // immutable
     var Offset: int  // immutable
     var IsNat: bool  // immutable
   }
 
   type _bv {
     function method RotateLeft(w: nat): selftype
 
     function method RotateRight(w: nat): selftype
   }
 
   type map<T, U> {
     var Keys: set<T>  // immutable
     var Values: set<U>  // immutable
     var Items: set<(T, U)>  // immutable
   }
 
   type imap<T, U> {
     var Keys: iset<T>  // immutable
     var Values: iset<U>  // immutable
     var Items: iset<(T, U)>  // immutable
   }
 
   datatype {:compile false} /*_tuple#0*/ () = _#Make0
 }
 // bitvector types in use: bv7 bv137 bv0 bv10 bv60 bv67 bv32 bv2 bv5 bv8 bv6 bv3
 */
 
 /* CALL GRAPH for module _module:
  * SCC at height 0:
  *   TestActualRotate
  * SCC at height 0:
  *   TestActualShifting
  * SCC at height 0:
  *   R
  * SCC at height 0:
  *   Q
  * SCC at height 0:
  *   P
  * SCC at height 0:
  *   N4
  * SCC at height 0:
  *   N3
  * SCC at height 0:
  *   N2
  * SCC at height 0:
  *   N1
  * SCC at height 0:
  *   N0
  * SCC at height 0:
  *   M
  * SCC at height 1:
  *   Rotate
  * SCC at height 2:
  *   Shifts6
  * SCC at height 2:
  *   Shifts5
  * SCC at height 2:
  *   Shifts4
  * SCC at height 2:
  *   Shifts3
  * SCC at height 2:
  *   Shifts2
  * SCC at height 2:
  *   Shifts1
  * SCC at height 2:
  *   Shifts0
  * SCC at height 1:
  *   PQ
  * SCC at height 0:
  *   Handful
  * SCC at height 0:
  *   SmallReal
  * SCC at height 0:
  *   EvenInt
  * SCC at height 0:
  *   nat
  */
 newtype EvenInt = x: int
   | x % 2 == 0
 
 newtype SmallReal = r: real
   | -4.0 <= r < 300.0
 
 newtype Handful = x: int
   | 0 <= x < 80
 
 method M()
 {
   var h: bv8 := 5;
   var k: bv8 := h * 128 / 128;
   assert k == 1;
   h := 3;
   k := h * 128 / 128;
   assert k == 1;
   h := *;
   k := k / h;
 }
 
 method N0(x: bv7, y: bv7)
   decreases x, y
 {
   var z: bv7 := x / y;
 }
 
 method N1(x: bv7, y: bv7)
   decreases x, y
 {
   var z: bv7 := x % y;
 }
 
 method N2(x: bv137, y: bv137)
   decreases x, y
 {
   var z: bv137 := x / y;
 }
 
 method N3(x: bv0, y: bv0)
   decreases x, y
 {
   if * {
     var z: bv0 := x / y;
   } else {
     var z: bv0 := x % y;
   }
 }
 
 method N4(x: bv0, y: bv0) returns (z: bv0)
   ensures z == 0
   decreases x, y
 {
   if {
     case true =>
       z := x + y;
     case true =>
       z := x - y;
     case true =>
       z := x * y;
     case true =>
       z := x & y;
     case true =>
       z := x | y;
     case true =>
       z := x ^ y;
     case true =>
       z := !x;
     case true =>
       z := -x;
     case true =>
     case true =>
       assert !(x < y);
     case true =>
       assert x <= y;
     case true =>
       assert x >= y;
     case true =>
       assert !(x > y);
   }
 }
 
 method P(x: bv0, y: bv0)
   requires x != y
   decreases x, y
 {
   assert false;
 }
 
 method Q(x: bv10, y: bv10)
   decreases x, y
 {
   if x < 0 {
     var z: bv10 := x / y;
   }
 }
 
 method R(x: bv60, y: bv60)
   decreases x, y
 {
   var a0: bool, a1: bool;
   a0, a1 := x < y, y > x;
   assert a0 == a1;
   a0, a1 := x <= y, y >= x;
   assert a0 == a1;
 }
 
 predicate PQ(x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   decreases x, n, r, even, small, b67, w, seven, bb, noll, h
 {
   x == x &&
   n == n &&
   r == r &&
   even == even &&
   small == small &&
   b67 == b67 &&
   w == w &&
   seven == seven &&
   bb == bb &&
   noll == noll &&
   h == h
 }
 
 method Shifts0()
     returns (x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   ensures PQ(x, n, r, even, small, b67, w, seven, bb, noll, h)
 {
   if {
     case x < 20 =>
       b67 := b67 << x as bv7;
     case 0 <= x =>
       b67 := b67 << x as bv7;
     case 0 <= x < 67 =>
       b67 := b67 << x as bv7;
     case true =>
       b67 := b67 << n as bv7;
     case true =>
       b67 := b67 << h as bv7;
   }
 }
 
 method Shifts1()
     returns (x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   ensures PQ(x, n, r, even, small, b67, w, seven, bb, noll, h)
 {
   if {
     case even <= 66 =>
       b67 := b67 << even as bv7;
     case 0 <= even =>
       b67 := b67 << even as bv7;
     case 0 <= even <= 66 =>
       b67 := b67 << even as bv7;
   }
 }
 
 method Shifts2()
     returns (x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   ensures PQ(x, n, r, even, small, b67, w, seven, bb, noll, h)
 {
   if {
     case true =>
       b67 := b67 << b67 as bv7;
     case true =>
       b67 := b67 << w as bv7;
     case true =>
       b67 := b67 << (seven / 2) as bv7;
     case true =>
       b67 := b67 << bb as bv7;
     case true =>
       b67 := b67 << noll as bv7;
   }
 }
 
 method Shifts3()
     returns (x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   ensures PQ(x, n, r, even, small, b67, w, seven, bb, noll, h)
 {
   if {
     case true =>
       w := w << b67 as bv6;
     case true =>
       w := w << w as bv6;
     case true =>
       w := w << seven as bv6;
     case true =>
       w := w << bb as bv6;
     case true =>
       w := w << noll as bv6;
   }
 }
 
 method Shifts4()
     returns (x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   ensures PQ(x, n, r, even, small, b67, w, seven, bb, noll, h)
 {
   if {
     case true =>
       seven := seven << b67 as bv3;
     case true =>
       seven := seven << w as bv3;
     case true =>
       seven := seven << seven as bv3;
     case true =>
       seven := seven << bb as bv3;
     case true =>
       seven := seven << noll as bv3;
   }
 }
 
 method Shifts5()
     returns (x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   ensures PQ(x, n, r, even, small, b67, w, seven, bb, noll, h)
 {
   if {
     case true =>
       bb := bb << b67 as bv2;
     case true =>
       bb := bb << w as bv2;
     case true =>
       bb := bb << seven as bv2;
     case true =>
       bb := bb << bb as bv2;
     case true =>
       bb := bb << noll as bv2;
   }
 }
 
 method Shifts6()
     returns (x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   ensures PQ(x, n, r, even, small, b67, w, seven, bb, noll, h)
 {
   if {
     case true =>
       noll := noll << b67 as bv0;
     case true =>
       noll := noll << w as bv0;
     case true =>
       noll := noll << seven as bv0;
     case true =>
       noll := noll << bb as bv0;
     case true =>
       noll := noll << noll as bv0;
   }
 }
 
 method TestActualShifting()
 {
   var a: bv67 := 3;
   assert a << 2 as bv7 == 12;
   assert a >> 0 as bv7 == 3;
   assert a >> 1 as bv7 == 1;
   assert a >> 2 as bv7 == 0;
   var b: bv5 := 24;
   assert b << 1 as bv3 == 16;
   assert b >> 0 as bv3 == 24;
   assert b >> 1 as bv3 == 12;
   assert b >> 2 as bv3 == 6;
 }
 
 method Rotate() returns (x: nat, bb: bv5)
 {
   if {
     case true =>
       bb := bb.RotateLeft(x);
     case true =>
       bb := bb.RotateRight(x);
   }
 }
 
 method TestActualRotate()
 {
   var a: bv5 := 12;
   assert a == a.RotateLeft(3).RotateRight(3);
 }
 BitvectorsMore.dfy(13,9): Error: possible division by zero
 BitvectorsMore.dfy(17,13): Error: possible division by zero
 BitvectorsMore.dfy(21,13): Error: possible division by zero
 BitvectorsMore.dfy(25,13): Error: possible division by zero
 BitvectorsMore.dfy(30,15): Error: possible division by zero
 BitvectorsMore.dfy(32,15): Error: possible division by zero
 BitvectorsMore.dfy(104,37): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(105,35): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(105,38): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(107,34): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(107,37): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(115,42): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(116,39): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(116,42): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(124,28): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(124,31): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(125,28): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(125,31): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
-BitvectorsMore.dfy(135,24): Error: shift amount must not exceed the width of the result (32)
 BitvectorsMore.dfy(135,27): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv6
 BitvectorsMore.dfy(136,24): Error: shift amount must not exceed the width of the result (32)
 BitvectorsMore.dfy(136,27): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv6
+BitvectorsMore.dfy(137,24): Error: shift amount must not exceed the width of the result (32)
 BitvectorsMore.dfy(137,27): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv6
 BitvectorsMore.dfy(146,35): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv3
 BitvectorsMore.dfy(147,35): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv3
 BitvectorsMore.dfy(148,35): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv3
 BitvectorsMore.dfy(157,26): Error: shift amount must not exceed the width of the result (2)
 BitvectorsMore.dfy(157,29): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv2
 BitvectorsMore.dfy(158,26): Error: shift amount must not exceed the width of the result (2)
 BitvectorsMore.dfy(158,29): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv2
 BitvectorsMore.dfy(159,29): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv2
 BitvectorsMore.dfy(168,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(169,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(170,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(171,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(193,26): Error: shift amount must not exceed the width of the result (5)
 BitvectorsMore.dfy(194,26): Error: shift amount must not exceed the width of the result (5)
 
 Dafny program verifier finished with 9 verified, 37 errors
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /print:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/BitvectorsMore.dfy.tmp.print /rprint:- /env:0 TestFiles/LitTests/LitTest/dafny0/BitvectorsMore.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/BitvectorsMore.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/dafny0/BitvectorsMore.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/BitvectorsMore.dfy.tmp
 Previous command results:
 Output:
 // BitvectorsMore.dfy
 
 /*
 module _System {
   /* CALL GRAPH for module _System:
    * SCC at height 1:
    *   RotateRight
    * SCC at height 1:
    *   RotateLeft
    * SCC at height 0:
    *   nat
    */
   type string(==,0) = seq<char>
 
   type {:axiom} nat(==,0) = x: int
     | 0 <= x
 
   trait {:compile false} object { }
   /*-- non-null type
   type {:axiom} object(==) = c: object? | c != null /*special witness*/
   */
 
   class {:compile false} array<arg> {
     var Length: int  // immutable
   }
   /*-- non-null type
   type {:axiom} array(==)<arg> = c: array?<arg> | c != null /*special witness*/
   */
 
   class {:compile false} /*_#Func1*/ -T0 ~> +R {
     function requires(x0: T0): bool
       reads reads(x0)
 
     function reads(x0: T0): set<object?>
       reads reads(x0)
   }
 
   type {:compile false} /*_#PartialFunc1*/ -T0 --> +R = f: T0 ~> R
     | forall x0: T0 :: f.reads(x0) == {}
     /*special witness*/
 
   type {:compile false} /*_#TotalFunc1*/ -T0 -> +R = f: T0 --> R
     | forall x0: T0 :: f.requires(x0)
     /*special witness*/
 
   class {:compile false} /*_#Func0*/ () ~> +R {
     function requires(): bool
       reads reads()
 
     function reads(): set<object?>
       reads reads()
   }
 
   type {:compile false} /*_#PartialFunc0*/ () --> +R = f: () ~> R
     | f.reads() == {}
     /*special witness*/
 
   type {:compile false} /*_#TotalFunc0*/ () -> +R = f: () --> R
     | f.requires()
     /*special witness*/
 
   class {:compile false} /*_#Func11*/ (-T0, -T1, -T2, -T3, -T4, -T5, -T6, -T7, -T8, -T9, -T10) ~> +R {
     function requires(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9, x10: T10): bool
       reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10)
 
     function reads(x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9, x10: T10): set<object?>
       reads reads(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10)
   }
 
   type {:compile false} /*_#PartialFunc11*/ (-T0, -T1, -T2, -T3, -T4, -T5, -T6, -T7, -T8, -T9, -T10) --> +R = f: (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) ~> R
     | forall x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9, x10: T10 :: f.reads(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10) == {}
     /*special witness*/
 
   type {:compile false} /*_#TotalFunc11*/ (-T0, -T1, -T2, -T3, -T4, -T5, -T6, -T7, -T8, -T9, -T10) -> +R = f: (T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10) --> R
     | forall x0: T0, x1: T1, x2: T2, x3: T3, x4: T4, x5: T5, x6: T6, x7: T7, x8: T8, x9: T9, x10: T10 :: f.requires(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10)
     /*special witness*/
 
   datatype {:compile false} /*_tuple#2*/ (+T0, +T1) = _#Make2(0: T0, 1: T1)
 
   type bool { }
 
   type int { }
 
   type real {
     var Floor: int  // immutable
   }
 
   type ORDINAL {
     var IsLimit: bool  // immutable
     var IsSucc: bool  // immutable
     var Offset: int  // immutable
     var IsNat: bool  // immutable
   }
 
   type _bv {
     function method RotateLeft(w: nat): selftype
 
     function method RotateRight(w: nat): selftype
   }
 
   type map<T, U> {
     var Keys: set<T>  // immutable
     var Values: set<U>  // immutable
     var Items: set<(T, U)>  // immutable
   }
 
   type imap<T, U> {
     var Keys: iset<T>  // immutable
     var Values: iset<U>  // immutable
     var Items: iset<(T, U)>  // immutable
   }
 
   datatype {:compile false} /*_tuple#0*/ () = _#Make0
 }
 // bitvector types in use: bv7 bv137 bv0 bv10 bv60 bv67 bv32 bv2 bv5 bv8 bv6 bv3
 */
 
 /* CALL GRAPH for module _module:
  * SCC at height 0:
  *   TestActualRotate
  * SCC at height 0:
  *   TestActualShifting
  * SCC at height 0:
  *   R
  * SCC at height 0:
  *   Q
  * SCC at height 0:
  *   P
  * SCC at height 0:
  *   N4
  * SCC at height 0:
  *   N3
  * SCC at height 0:
  *   N2
  * SCC at height 0:
  *   N1
  * SCC at height 0:
  *   N0
  * SCC at height 0:
  *   M
  * SCC at height 1:
  *   Rotate
  * SCC at height 2:
  *   Shifts6
  * SCC at height 2:
  *   Shifts5
  * SCC at height 2:
  *   Shifts4
  * SCC at height 2:
  *   Shifts3
  * SCC at height 2:
  *   Shifts2
  * SCC at height 2:
  *   Shifts1
  * SCC at height 2:
  *   Shifts0
  * SCC at height 1:
  *   PQ
  * SCC at height 0:
  *   Handful
  * SCC at height 0:
  *   SmallReal
  * SCC at height 0:
  *   EvenInt
  * SCC at height 0:
  *   nat
  */
 newtype EvenInt = x: int
   | x % 2 == 0
 
 newtype SmallReal = r: real
   | -4.0 <= r < 300.0
 
 newtype Handful = x: int
   | 0 <= x < 80
 
 method M()
 {
   var h: bv8 := 5;
   var k: bv8 := h * 128 / 128;
   assert k == 1;
   h := 3;
   k := h * 128 / 128;
   assert k == 1;
   h := *;
   k := k / h;
 }
 
 method N0(x: bv7, y: bv7)
   decreases x, y
 {
   var z: bv7 := x / y;
 }
 
 method N1(x: bv7, y: bv7)
   decreases x, y
 {
   var z: bv7 := x % y;
 }
 
 method N2(x: bv137, y: bv137)
   decreases x, y
 {
   var z: bv137 := x / y;
 }
 
 method N3(x: bv0, y: bv0)
   decreases x, y
 {
   if * {
     var z: bv0 := x / y;
   } else {
     var z: bv0 := x % y;
   }
 }
 
 method N4(x: bv0, y: bv0) returns (z: bv0)
   ensures z == 0
   decreases x, y
 {
   if {
     case true =>
       z := x + y;
     case true =>
       z := x - y;
     case true =>
       z := x * y;
     case true =>
       z := x & y;
     case true =>
       z := x | y;
     case true =>
       z := x ^ y;
     case true =>
       z := !x;
     case true =>
       z := -x;
     case true =>
     case true =>
       assert !(x < y);
     case true =>
       assert x <= y;
     case true =>
       assert x >= y;
     case true =>
       assert !(x > y);
   }
 }
 
 method P(x: bv0, y: bv0)
   requires x != y
   decreases x, y
 {
   assert false;
 }
 
 method Q(x: bv10, y: bv10)
   decreases x, y
 {
   if x < 0 {
     var z: bv10 := x / y;
   }
 }
 
 method R(x: bv60, y: bv60)
   decreases x, y
 {
   var a0: bool, a1: bool;
   a0, a1 := x < y, y > x;
   assert a0 == a1;
   a0, a1 := x <= y, y >= x;
   assert a0 == a1;
 }
 
 predicate PQ(x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   decreases x, n, r, even, small, b67, w, seven, bb, noll, h
 {
   x == x &&
   n == n &&
   r == r &&
   even == even &&
   small == small &&
   b67 == b67 &&
   w == w &&
   seven == seven &&
   bb == bb &&
   noll == noll &&
   h == h
 }
 
 method Shifts0()
     returns (x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   ensures PQ(x, n, r, even, small, b67, w, seven, bb, noll, h)
 {
   if {
     case x < 20 =>
       b67 := b67 << x as bv7;
     case 0 <= x =>
       b67 := b67 << x as bv7;
     case 0 <= x < 67 =>
       b67 := b67 << x as bv7;
     case true =>
       b67 := b67 << n as bv7;
     case true =>
       b67 := b67 << h as bv7;
   }
 }
 
 method Shifts1()
     returns (x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   ensures PQ(x, n, r, even, small, b67, w, seven, bb, noll, h)
 {
   if {
     case even <= 66 =>
       b67 := b67 << even as bv7;
     case 0 <= even =>
       b67 := b67 << even as bv7;
     case 0 <= even <= 66 =>
       b67 := b67 << even as bv7;
   }
 }
 
 method Shifts2()
     returns (x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   ensures PQ(x, n, r, even, small, b67, w, seven, bb, noll, h)
 {
   if {
     case true =>
       b67 := b67 << b67 as bv7;
     case true =>
       b67 := b67 << w as bv7;
     case true =>
       b67 := b67 << (seven / 2) as bv7;
     case true =>
       b67 := b67 << bb as bv7;
     case true =>
       b67 := b67 << noll as bv7;
   }
 }
 
 method Shifts3()
     returns (x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   ensures PQ(x, n, r, even, small, b67, w, seven, bb, noll, h)
 {
   if {
     case true =>
       w := w << b67 as bv6;
     case true =>
       w := w << w as bv6;
     case true =>
       w := w << seven as bv6;
     case true =>
       w := w << bb as bv6;
     case true =>
       w := w << noll as bv6;
   }
 }
 
 method Shifts4()
     returns (x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   ensures PQ(x, n, r, even, small, b67, w, seven, bb, noll, h)
 {
   if {
     case true =>
       seven := seven << b67 as bv3;
     case true =>
       seven := seven << w as bv3;
     case true =>
       seven := seven << seven as bv3;
     case true =>
       seven := seven << bb as bv3;
     case true =>
       seven := seven << noll as bv3;
   }
 }
 
 method Shifts5()
     returns (x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   ensures PQ(x, n, r, even, small, b67, w, seven, bb, noll, h)
 {
   if {
     case true =>
       bb := bb << b67 as bv2;
     case true =>
       bb := bb << w as bv2;
     case true =>
       bb := bb << seven as bv2;
     case true =>
       bb := bb << bb as bv2;
     case true =>
       bb := bb << noll as bv2;
   }
 }
 
 method Shifts6()
     returns (x: int, n: nat, r: real, even: EvenInt, small: SmallReal, b67: bv67, w: bv32, seven: bv7, bb: bv2, noll: bv0, h: Handful)
   ensures PQ(x, n, r, even, small, b67, w, seven, bb, noll, h)
 {
   if {
     case true =>
       noll := noll << b67 as bv0;
     case true =>
       noll := noll << w as bv0;
     case true =>
       noll := noll << seven as bv0;
     case true =>
       noll := noll << bb as bv0;
     case true =>
       noll := noll << noll as bv0;
   }
 }
 
 method TestActualShifting()
 {
   var a: bv67 := 3;
   assert a << 2 as bv7 == 12;
   assert a >> 0 as bv7 == 3;
   assert a >> 1 as bv7 == 1;
   assert a >> 2 as bv7 == 0;
   var b: bv5 := 24;
   assert b << 1 as bv3 == 16;
   assert b >> 0 as bv3 == 24;
   assert b >> 1 as bv3 == 12;
   assert b >> 2 as bv3 == 6;
 }
 
 method Rotate() returns (x: nat, bb: bv5)
 {
   if {
     case true =>
       bb := bb.RotateLeft(x);
     case true =>
       bb := bb.RotateRight(x);
   }
 }
 
 method TestActualRotate()
 {
   var a: bv5 := 12;
   assert a == a.RotateLeft(3).RotateRight(3);
 }
 BitvectorsMore.dfy(13,9): Error: possible division by zero
 BitvectorsMore.dfy(17,13): Error: possible division by zero
 BitvectorsMore.dfy(21,13): Error: possible division by zero
 BitvectorsMore.dfy(25,13): Error: possible division by zero
 BitvectorsMore.dfy(30,15): Error: possible division by zero
 BitvectorsMore.dfy(32,15): Error: possible division by zero
 BitvectorsMore.dfy(104,37): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(105,35): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(105,38): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(107,34): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(107,37): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(115,42): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(116,39): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(116,42): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(124,28): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(124,31): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(125,28): Error: shift amount must not exceed the width of the result (67)
 BitvectorsMore.dfy(125,31): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv7
 BitvectorsMore.dfy(135,27): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv6
 BitvectorsMore.dfy(136,24): Error: shift amount must not exceed the width of the result (32)
 BitvectorsMore.dfy(136,27): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv6
 BitvectorsMore.dfy(137,24): Error: shift amount must not exceed the width of the result (32)
 BitvectorsMore.dfy(137,27): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv6
 BitvectorsMore.dfy(146,35): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv3
 BitvectorsMore.dfy(147,35): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv3
 BitvectorsMore.dfy(148,35): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv3
 BitvectorsMore.dfy(157,26): Error: shift amount must not exceed the width of the result (2)
 BitvectorsMore.dfy(157,29): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv2
 BitvectorsMore.dfy(158,26): Error: shift amount must not exceed the width of the result (2)
 BitvectorsMore.dfy(158,29): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv2
 BitvectorsMore.dfy(159,29): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv2
 BitvectorsMore.dfy(168,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(169,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(170,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(171,33): Error: when converting shift amount to a bit vector, the value to be converted might not fit in bv0
 BitvectorsMore.dfy(193,26): Error: shift amount must not exceed the width of the result (5)
 BitvectorsMore.dfy(194,26): Error: shift amount must not exceed the width of the result (5)
 
 Dafny program verifier finished with 9 verified, 37 errors
 
 Error:
 


[xUnit.net 00:33:06.34]     dafny0/ExtremeReads.dfy [FAIL]
  Failed dafny0/ExtremeReads.dfy [20 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/dafny0/ExtremeReads.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/ExtremeReads.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
 ExtremeReads.dfy(47,11): Error: assertion might not hold
 ExtremeReads.dfy(13,20): Related location
 ExtremeReads.dfy(50,11): Error: assertion might not hold
 ExtremeReads.dfy(13,20): Related location
 ExtremeReads.dfy(69,11): Error: assertion might not hold
 ExtremeReads.dfy(20,20): Related location
 ExtremeReads.dfy(83,11): Error: assertion might not hold
 ExtremeReads.dfy(26,2): Related location
 ExtremeReads.dfy(105,11): Error: assertion might not hold
 ExtremeReads.dfy(89,2): Related location
 ExtremeReads.dfy(127,11): Error: assertion might not hold
+ExtremeReads.dfy(13,20): Related location
+ExtremeReads.dfy(127,11): Error: assertion might not hold
 ExtremeReads.dfy(9,19): Related location
-ExtremeReads.dfy(127,11): Error: assertion might not hold
-ExtremeReads.dfy(13,20): Related location
 ExtremeReads.dfy(130,11): Error: assertion might not hold
 ExtremeReads.dfy(9,19): Related location
 ExtremeReads.dfy(130,11): Error: assertion might not hold
 ExtremeReads.dfy(13,20): Related location
 ExtremeReads.dfy(149,11): Error: assertion might not hold
+ExtremeReads.dfy(20,20): Related location
+ExtremeReads.dfy(149,11): Error: assertion might not hold
 ExtremeReads.dfy(16,19): Related location
-ExtremeReads.dfy(149,11): Error: assertion might not hold
-ExtremeReads.dfy(20,20): Related location
+ExtremeReads.dfy(168,11): Error: assertion might not hold
+ExtremeReads.dfy(26,2): Related location
 ExtremeReads.dfy(168,11): Error: assertion might not hold
 ExtremeReads.dfy(23,19): Related location
-ExtremeReads.dfy(168,11): Error: assertion might not hold
+ExtremeReads.dfy(171,11): Error: assertion might not hold
 ExtremeReads.dfy(26,2): Related location
 ExtremeReads.dfy(171,11): Error: assertion might not hold
 ExtremeReads.dfy(23,19): Related location
-ExtremeReads.dfy(171,11): Error: assertion might not hold
-ExtremeReads.dfy(26,2): Related location
+ExtremeReads.dfy(181,11): Error: assertion might not hold
+ExtremeReads.dfy(89,2): Related location
 ExtremeReads.dfy(181,11): Error: assertion might not hold
 ExtremeReads.dfy(86,16): Related location
-ExtremeReads.dfy(181,11): Error: assertion might not hold
-ExtremeReads.dfy(89,2): Related location
 
 Dafny program verifier finished with 10 verified, 17 errors
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 TestFiles/LitTests/LitTest/dafny0/ExtremeReads.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/ExtremeReads.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/dafny0/ExtremeReads.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/ExtremeReads.dfy.tmp
 Previous command results:
 Output:
 ExtremeReads.dfy(47,11): Error: assertion might not hold
 ExtremeReads.dfy(13,20): Related location
 ExtremeReads.dfy(50,11): Error: assertion might not hold
 ExtremeReads.dfy(13,20): Related location
 ExtremeReads.dfy(69,11): Error: assertion might not hold
 ExtremeReads.dfy(20,20): Related location
 ExtremeReads.dfy(83,11): Error: assertion might not hold
 ExtremeReads.dfy(26,2): Related location
 ExtremeReads.dfy(105,11): Error: assertion might not hold
 ExtremeReads.dfy(89,2): Related location
 ExtremeReads.dfy(127,11): Error: assertion might not hold
 ExtremeReads.dfy(13,20): Related location
 ExtremeReads.dfy(127,11): Error: assertion might not hold
 ExtremeReads.dfy(9,19): Related location
 ExtremeReads.dfy(130,11): Error: assertion might not hold
 ExtremeReads.dfy(9,19): Related location
 ExtremeReads.dfy(130,11): Error: assertion might not hold
 ExtremeReads.dfy(13,20): Related location
 ExtremeReads.dfy(149,11): Error: assertion might not hold
 ExtremeReads.dfy(20,20): Related location
 ExtremeReads.dfy(149,11): Error: assertion might not hold
 ExtremeReads.dfy(16,19): Related location
 ExtremeReads.dfy(168,11): Error: assertion might not hold
 ExtremeReads.dfy(26,2): Related location
 ExtremeReads.dfy(168,11): Error: assertion might not hold
 ExtremeReads.dfy(23,19): Related location
 ExtremeReads.dfy(171,11): Error: assertion might not hold
 ExtremeReads.dfy(26,2): Related location
 ExtremeReads.dfy(171,11): Error: assertion might not hold
 ExtremeReads.dfy(23,19): Related location
 ExtremeReads.dfy(181,11): Error: assertion might not hold
 ExtremeReads.dfy(89,2): Related location
 ExtremeReads.dfy(181,11): Error: assertion might not hold
 ExtremeReads.dfy(86,16): Related location
 
 Dafny program verifier finished with 10 verified, 17 errors
 
 Error:
 


[xUnit.net 00:33:44.00]     dafny0/Fuel.dfy [FAIL]
  Failed dafny0/Fuel.dfy [37 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/dafny0/Fuel.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/Fuel.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
 Fuel.dfy(129,8): Error: Fuel can only increase within a given scope.
 Fuel.dfy(407,8): Error: Fuel can only increase within a given scope.
 Fuel.dfy(17,22): Error: assertion might not hold
 Fuel.dfy(65,27): Error: assertion might not hold
 Fuel.dfy(69,27): Error: assertion might not hold
 Fuel.dfy(92,22): Error: assertion might not hold
 Fuel.dfy(93,23): Error: assertion might not hold
 Fuel.dfy(94,22): Error: assertion might not hold
 Fuel.dfy(120,22): Error: assertion might not hold
 Fuel.dfy(121,23): Error: assertion might not hold
 Fuel.dfy(122,22): Error: assertion might not hold
 Fuel.dfy(132,26): Error: assertion might not hold
 Fuel.dfy(133,26): Error: assertion might not hold
 Fuel.dfy(157,22): Error: assertion might not hold
 Fuel.dfy(200,55): Error: assertion might not hold
 Fuel.dfy(245,22): Error: assertion might not hold
 Fuel.dfy(247,22): Error: assertion might not hold
 Fuel.dfy(280,26): Error: assertion might not hold
 Fuel.dfy(335,26): Error: function precondition might not hold
 Fuel.dfy(324,21): Related location
-Fuel.dfy(312,43): Related location
+Fuel.dfy(314,46): Related location
 Fuel.dfy(335,26): Error: function precondition might not hold
 Fuel.dfy(324,21): Related location
-Fuel.dfy(312,58): Related location
+Fuel.dfy(314,72): Related location
 Fuel.dfy(335,26): Error: function precondition might not hold
 Fuel.dfy(324,21): Related location
-Fuel.dfy(313,41): Related location
+Fuel.dfy(314,93): Related location
 Fuel.dfy(335,26): Error: function precondition might not hold
 Fuel.dfy(324,21): Related location
-Fuel.dfy(314,46): Related location
+Fuel.dfy(312,43): Related location
 Fuel.dfy(335,26): Error: function precondition might not hold
 Fuel.dfy(324,21): Related location
-Fuel.dfy(314,72): Related location
+Fuel.dfy(312,58): Related location
-Fuel.dfy(335,26): Error: function precondition might not hold
-Fuel.dfy(324,21): Related location
-Fuel.dfy(314,93): Related location
 Fuel.dfy(335,49): Error: destructor 't' can only be applied to datatype values constructed by 'VTuple'
 Fuel.dfy(335,50): Error: index out of range
 Fuel.dfy(336,38): Error: index out of range
 Fuel.dfy(336,42): Error: destructor 'u' can only be applied to datatype values constructed by 'VUint64'
+Fuel.dfy(336,71): Error: index out of range
 Fuel.dfy(397,22): Error: assertion might not hold
 Fuel.dfy(398,22): Error: assertion might not hold
 Fuel.dfy(399,23): Error: assertion might not hold
 Fuel.dfy(435,22): Error: assertion might not hold
 Fuel.dfy(436,22): Error: assertion might not hold
 Fuel.dfy(437,23): Error: assertion might not hold
 
 Dafny program verifier finished with 30 verified, 32 errors
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /print:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/Fuel.dfy.tmp.print /dprint:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/Fuel.dfy.tmp.dprint /autoTriggers:0 /optimizeResolution:0 /errorLimit:10 TestFiles/LitTests/LitTest/dafny0/Fuel.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/Fuel.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/dafny0/Fuel.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/Fuel.dfy.tmp
 Previous command results:
 Output:
 Fuel.dfy(129,8): Error: Fuel can only increase within a given scope.
 Fuel.dfy(407,8): Error: Fuel can only increase within a given scope.
 Fuel.dfy(17,22): Error: assertion might not hold
 Fuel.dfy(65,27): Error: assertion might not hold
 Fuel.dfy(69,27): Error: assertion might not hold
 Fuel.dfy(92,22): Error: assertion might not hold
 Fuel.dfy(93,23): Error: assertion might not hold
 Fuel.dfy(94,22): Error: assertion might not hold
 Fuel.dfy(120,22): Error: assertion might not hold
 Fuel.dfy(121,23): Error: assertion might not hold
 Fuel.dfy(122,22): Error: assertion might not hold
 Fuel.dfy(132,26): Error: assertion might not hold
 Fuel.dfy(133,26): Error: assertion might not hold
 Fuel.dfy(157,22): Error: assertion might not hold
 Fuel.dfy(200,55): Error: assertion might not hold
 Fuel.dfy(245,22): Error: assertion might not hold
 Fuel.dfy(247,22): Error: assertion might not hold
 Fuel.dfy(280,26): Error: assertion might not hold
 Fuel.dfy(335,26): Error: function precondition might not hold
 Fuel.dfy(324,21): Related location
 Fuel.dfy(314,46): Related location
 Fuel.dfy(335,26): Error: function precondition might not hold
 Fuel.dfy(324,21): Related location
 Fuel.dfy(314,72): Related location
 Fuel.dfy(335,26): Error: function precondition might not hold
 Fuel.dfy(324,21): Related location
 Fuel.dfy(314,93): Related location
 Fuel.dfy(335,26): Error: function precondition might not hold
 Fuel.dfy(324,21): Related location
 Fuel.dfy(312,43): Related location
 Fuel.dfy(335,26): Error: function precondition might not hold
 Fuel.dfy(324,21): Related location
 Fuel.dfy(312,58): Related location
 Fuel.dfy(335,49): Error: destructor 't' can only be applied to datatype values constructed by 'VTuple'
 Fuel.dfy(335,50): Error: index out of range
 Fuel.dfy(336,38): Error: index out of range
 Fuel.dfy(336,42): Error: destructor 'u' can only be applied to datatype values constructed by 'VUint64'
 Fuel.dfy(336,71): Error: index out of range
 Fuel.dfy(397,22): Error: assertion might not hold
 Fuel.dfy(398,22): Error: assertion might not hold
 Fuel.dfy(399,23): Error: assertion might not hold
 Fuel.dfy(435,22): Error: assertion might not hold
 Fuel.dfy(436,22): Error: assertion might not hold
 Fuel.dfy(437,23): Error: assertion might not hold
 
 Dafny program verifier finished with 30 verified, 32 errors
 
 Error:
 


[xUnit.net 00:34:34.18]     dafny0/Inverses.dfy [FAIL]
  Failed dafny0/Inverses.dfy [35 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/dafny0/Inverses.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/Inverses.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
 Inverses.dfy(70,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(67,10): Related location: This is the postcondition that might not hold.
 Inverses.dfy(67,66): Related location
 Inverses.dfy(82,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(79,10): Related location: This is the postcondition that might not hold.
 Inverses.dfy(79,66): Related location
+Inverses.dfy(94,2): Error: A postcondition might not hold on this return path.
+Inverses.dfy(91,10): Related location: This is the postcondition that might not hold.
+Inverses.dfy(91,66): Related location
+Inverses.dfy(104,2): Error: A postcondition might not hold on this return path.
+Inverses.dfy(101,10): Related location: This is the postcondition that might not hold.
+Inverses.dfy(101,66): Related location
 Inverses.dfy(193,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(191,15): Related location: This is the postcondition that might not hold.
 
-Dafny program verifier finished with 31 verified, 3 errors
+Dafny program verifier finished with 29 verified, 5 errors
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /print:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/Inverses.dfy.tmp.print /dprint:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/Inverses.dfy.tmp.dprint TestFiles/LitTests/LitTest/dafny0/Inverses.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/Inverses.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/dafny0/Inverses.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny0/Output/Inverses.dfy.tmp
 Previous command results:
 Output:
 Inverses.dfy(70,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(67,10): Related location: This is the postcondition that might not hold.
 Inverses.dfy(67,66): Related location
 Inverses.dfy(82,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(79,10): Related location: This is the postcondition that might not hold.
 Inverses.dfy(79,66): Related location
 Inverses.dfy(94,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(91,10): Related location: This is the postcondition that might not hold.
 Inverses.dfy(91,66): Related location
 Inverses.dfy(104,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(101,10): Related location: This is the postcondition that might not hold.
 Inverses.dfy(101,66): Related location
 Inverses.dfy(193,2): Error: A postcondition might not hold on this return path.
 Inverses.dfy(191,15): Related location: This is the postcondition that might not hold.
 
 Dafny program verifier finished with 29 verified, 5 errors
 
 Error:
 


[xUnit.net 00:40:59.45]     dafny0/snapshots/Snapshots6.run.dfy [SKIP]
  Skipped dafny0/snapshots/Snapshots6.run.dfy [1 ms]
[xUnit.net 00:41:03.26]     dafny0/snapshots/Snapshots7.run.dfy [SKIP]
  Skipped dafny0/snapshots/Snapshots7.run.dfy [1 ms]
[xUnit.net 00:49:05.00]     concurrency/12-MutexLifetime-short.dfy [FAIL]
  Failed concurrency/12-MutexLifetime-short.dfy [24 m 25 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (4): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /proverOpt:O:smt.qi.eager_threshold=30 TestFiles/LitTests/LitTest/concurrency/12-MutexLifetime-short.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/concurrency/Output/12-MutexLifetime-short.dfy.tmp
Output:
12-MutexLifetime-short.dfy(889,2): Verification of 'MutexGuardU32._ctor (correctness)' timed out after 900 seconds

Dafny program verifier finished with 201 verified, 0 errors, 1 time out

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /proverOpt:O:smt.qi.eager_threshold=30 TestFiles/LitTests/LitTest/concurrency/12-MutexLifetime-short.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/concurrency/Output/12-MutexLifetime-short.dfy.tmp
 Previous command results:


[xUnit.net 00:50:14.83]     dafny1/SchorrWaite.dfy [FAIL]
  Failed dafny1/SchorrWaite.dfy [5 m 53 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (4): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /dprint:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny1/Output/SchorrWaite.dfy.tmp.dprint TestFiles/LitTests/LitTest/dafny1/SchorrWaite.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny1/Output/SchorrWaite.dfy.tmp
Output:
SchorrWaite.dfy(169,7): Verification of 'SchorrWaite (correctness)' timed out after 300 seconds

Dafny program verifier finished with 9 verified, 0 errors, 1 time out

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /dprint:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny1/Output/SchorrWaite.dfy.tmp.dprint TestFiles/LitTests/LitTest/dafny1/SchorrWaite.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny1/Output/SchorrWaite.dfy.tmp
 Previous command results:


[xUnit.net 00:51:29.58]     dafny3/Filter.dfy [FAIL]
  Failed dafny3/Filter.dfy [54 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (4): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /dprint:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny3/Output/Filter.dfy.tmp.dprint TestFiles/LitTests/LitTest/dafny3/Filter.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny3/Output/Filter.dfy.tmp
Output:
Filter.dfy(222,9): Error: A postcondition might not hold on this return path.
Filter.dfy(207,10): Related location: This is the postcondition that might not hold.
Filter.dfy(12,2): Related location
Filter.dfy(12,40): Related location

Dafny program verifier finished with 27 verified, 1 error

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /dprint:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny3/Output/Filter.dfy.tmp.dprint TestFiles/LitTests/LitTest/dafny3/Filter.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny3/Output/Filter.dfy.tmp
 Previous command results:


[xUnit.net 00:57:45.04]     dafny4/ACL2-extractor.dfy [FAIL]
  Failed dafny4/ACL2-extractor.dfy [5 m 32 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (4): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /dprint:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny4/Output/ACL2-extractor.dfy.tmp.dprint TestFiles/LitTests/LitTest/dafny4/ACL2-extractor.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny4/Output/ACL2-extractor.dfy.tmp
Output:
ACL2-extractor.dfy(142,6): Verification of 'ExtractorLemma (correctness)' timed out after 300 seconds

Dafny program verifier finished with 21 verified, 0 errors, 1 time out

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /dprint:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny4/Output/ACL2-extractor.dfy.tmp.dprint TestFiles/LitTests/LitTest/dafny4/ACL2-extractor.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny4/Output/ACL2-extractor.dfy.tmp
 Previous command results:


[xUnit.net 00:59:07.90]     dafny2/SnapshotableTrees.dfy [FAIL]
  Failed dafny2/SnapshotableTrees.dfy [12 m 59 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/dafny2/SnapshotableTrees.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny2/Output/SnapshotableTrees.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
+SnapshotableTrees.dfy(594,11): Verification of 'SnapTree.Iterator.MoveNext (correctness)' timed out after 300 seconds
+SnapshotableTrees.dfy(12,9): Verification of 'SnapTreeTestHarness.Main (correctness)' timed out after 300 seconds
 SnapshotableTrees.dfy(71,25): Error: A precondition for this call might not hold.
 SnapshotableTrees.dfy(595,15): Related location: This is the precondition that might not hold.
 SnapshotableTrees.dfy(497,18): Related location
 SnapshotableTrees.dfy(515,10): Related location
 SnapshotableTrees.dfy(71,25): Error: A precondition for this call might not hold.
 SnapshotableTrees.dfy(595,15): Related location: This is the precondition that might not hold.
 SnapshotableTrees.dfy(497,18): Related location
 SnapshotableTrees.dfy(515,29): Related location
 SnapshotableTrees.dfy(71,25): Error: A precondition for this call might not hold.
 SnapshotableTrees.dfy(595,15): Related location: This is the precondition that might not hold.
 SnapshotableTrees.dfy(497,18): Related location
 SnapshotableTrees.dfy(515,43): Related location
 SnapshotableTrees.dfy(71,25): Error: A precondition for this call might not hold.
 SnapshotableTrees.dfy(595,15): Related location: This is the precondition that might not hold.
 SnapshotableTrees.dfy(497,18): Related location
 SnapshotableTrees.dfy(516,31): Related location
 SnapshotableTrees.dfy(71,25): Error: A precondition for this call might not hold.
 SnapshotableTrees.dfy(595,15): Related location: This is the precondition that might not hold.
 SnapshotableTrees.dfy(497,18): Related location
 SnapshotableTrees.dfy(518,9): Related location
 
-Dafny program verifier finished with 52 verified, 5 errors
+Dafny program verifier finished with 50 verified, 5 errors, 2 time outs
 Main iterates on -15
 Main iterates on 0
 Main iterates on 1
 Main iterates on 2
 Main iterates on 3
 Tree: -45 -15 0 1 2 3 6 9
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:4 /dprint:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny2/Output/SnapshotableTrees.dfy.tmp.dprint TestFiles/LitTests/LitTest/dafny2/SnapshotableTrees.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny2/Output/SnapshotableTrees.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/dafny2/SnapshotableTrees.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny2/Output/SnapshotableTrees.dfy.tmp
 Previous command results:
 Output:
 SnapshotableTrees.dfy(594,11): Verification of 'SnapTree.Iterator.MoveNext (correctness)' timed out after 300 seconds
 SnapshotableTrees.dfy(12,9): Verification of 'SnapTreeTestHarness.Main (correctness)' timed out after 300 seconds
 SnapshotableTrees.dfy(71,25): Error: A precondition for this call might not hold.
 SnapshotableTrees.dfy(595,15): Related location: This is the precondition that might not hold.
 SnapshotableTrees.dfy(497,18): Related location
 SnapshotableTrees.dfy(515,10): Related location
 SnapshotableTrees.dfy(71,25): Error: A precondition for this call might not hold.
 SnapshotableTrees.dfy(595,15): Related location: This is the precondition that might not hold.
 SnapshotableTrees.dfy(497,18): Related location
 SnapshotableTrees.dfy(515,29): Related location
 SnapshotableTrees.dfy(71,25): Error: A precondition for this call might not hold.
 SnapshotableTrees.dfy(595,15): Related location: This is the precondition that might not hold.
 SnapshotableTrees.dfy(497,18): Related location
 SnapshotableTrees.dfy(515,43): Related location
 SnapshotableTrees.dfy(71,25): Error: A precondition for this call might not hold.
 SnapshotableTrees.dfy(595,15): Related location: This is the precondition that might not hold.
 SnapshotableTrees.dfy(497,18): Related location
 SnapshotableTrees.dfy(516,31): Related location
 SnapshotableTrees.dfy(71,25): Error: A precondition for this call might not hold.
 SnapshotableTrees.dfy(595,15): Related location: This is the precondition that might not hold.
 SnapshotableTrees.dfy(497,18): Related location
 SnapshotableTrees.dfy(518,9): Related location
 
 Dafny program verifier finished with 50 verified, 5 errors, 2 time outs
 Main iterates on -15
 Main iterates on 0
 Main iterates on 1
 Main iterates on 2
 Main iterates on 3
 Tree: -45 -15 0 1 2 3 6 9
 
 Error:
 


[xUnit.net 01:05:46.97]     DafnyTestGeneration/TestGeneration.dfy [FAIL]
  Failed DafnyTestGeneration/TestGeneration.dfy [1 m 39 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): OutputCheck --file-to-check /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/DafnyTestGeneration/Output/TestGeneration.dfy.tmp TestFiles/LitTests/LitTest/DafnyTestGeneration/TestGeneration.dfy
Output:

Error:
ERROR: Could not find a match for Check Directive (TestFiles/LitTests/LitTest/DafnyTestGeneration/TestGeneration.dfy:8 Pattern: '.*Passed!  - Failed:     0, Passed:     3, Skipped:     0, Total:     3*')
  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: cp /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/DafnyTestGeneration/TestGeneration.dfy /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/DafnyTestGeneration/Output/TestGeneration.dfy.tmp.dfy
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /definiteAssignment:3 /generateTestMode:Block /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/DafnyTestGeneration/Output/TestGeneration.dfy.tmp.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/DafnyTestGeneration/Output/TestGeneration.dfy.tmp-tests.dfy
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compileVerbose:1 /compile:0 /spillTargetCode:3 /noVerify /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/DafnyTestGeneration/Output/TestGeneration.dfy.tmp-tests.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/DafnyTestGeneration/Output/TestGeneration.dfy.tmp
 Executing command: dotnet test -v:q -noLogo /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/DafnyTestGeneration >> /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/DafnyTestGeneration/Output/TestGeneration.dfy.tmp || true 
 Executing command: OutputCheck --file-to-check /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/DafnyTestGeneration/Output/TestGeneration.dfy.tmp TestFiles/LitTests/LitTest/DafnyTestGeneration/TestGeneration.dfy
 Previous command results:
 Output:
 
 Error:
 ERROR: Could not find a match for Check Directive (TestFiles/LitTests/LitTest/DafnyTestGeneration/TestGeneration.dfy:8 Pattern: '.*Passed!  - Failed:     0, Passed:     3, Skipped:     0, Total:     3*')
 Output:
 include "/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/DafnyTestGeneration/Output/TestGeneration.dfy.tmp.dfy"
 module TestGenerationUnitTests {
 import M
 Prover error: line 9 column 28: unknown parameter 'model_compress'
 Legal parameters are:
   auto_config (bool) (default: true)
   debug_ref_count (bool) (default: false)
   dot_proof_file (string) (default: proof.dot)
   dump_models (bool) (default: false)
   memory_high_watermark (unsigned int) (default: 0)
   memory_max_alloc_count (unsigned int) (default: 0)
   memory_max_size (unsigned int) (default: 0)
   model (bool) (default: true)
   model_validate (bool) (default: false)
   proof (bool) (default: false)
   rlimit (unsigned int) (default: 0)
   smtlib2_compliant (bool) (default: false)
   stats (bool) (default: false)
   timeout (unsigned int) (default: 4294967295)
   trace (bool) (default: false)
   trace_file_name (string) (default: z3.log)
   type_check (bool) (default: true)
   unsat_core (bool) (default: false)
   verbose (unsigned int) (default: 0)
   warning (bool) (default: true)
   well_sorted_check (bool) (default: false)
 
 Fatal Error: ProverException: Prover died with no further output, perhaps it ran out of memory or was killed.
 Prover error: line 9 column 28: unknown parameter 'model_compress'
 Legal parameters are:
   auto_config (bool) (default: true)
   debug_ref_count (bool) (default: false)
   dot_proof_file (string) (default: proof.dot)
   dump_models (bool) (default: false)
   memory_high_watermark (unsigned int) (default: 0)
   memory_max_alloc_count (unsigned int) (default: 0)
   memory_max_size (unsigned int) (default: 0)
   model (bool) (default: true)
   model_validate (bool) (default: false)
   proof (bool) (default: false)
   rlimit (unsigned int) (default: 0)
   smtlib2_compliant (bool) (default: false)
   stats (bool) (default: false)
   timeout (unsigned int) (default: 4294967295)
   trace (bool) (default: false)
   trace_file_name (string) (default: z3.log)
   type_check (bool) (default: true)
   unsat_core (bool) (default: false)
   verbose (unsigned int) (default: 0)
   warning (bool) (default: true)
   well_sorted_check (bool) (default: false)
 
 Fatal Error: ProverException: Prover died with no further output, perhaps it ran out of memory or was killed.
 Prover error: line 9 column 28: unknown parameter 'model_compress'
 Legal parameters are:
   auto_config (bool) (default: true)
   debug_ref_count (bool) (default: false)
   dot_proof_file (string) (default: proof.dot)
   dump_models (bool) (default: false)
   memory_high_watermark (unsigned int) (default: 0)
   memory_max_alloc_count (unsigned int) (default: 0)
   memory_max_size (unsigned int) (default: 0)
   model (bool) (default: true)
   model_validate (bool) (default: false)
   proof (bool) (default: false)
   rlimit (unsigned int) (default: 0)
   smtlib2_compliant (bool) (default: false)
   stats (bool) (default: false)
   timeout (unsigned int) (default: 4294967295)
   trace (bool) (default: false)
   trace_file_name (string) (default: z3.log)
   type_check (bool) (default: true)
   unsat_core (bool) (default: false)
   verbose (unsigned int) (default: 0)
   warning (bool) (default: true)
   well_sorted_check (bool) (default: false)
 
 Fatal Error: ProverException: Prover died with no further output, perhaps it ran out of memory or was killed.
 Prover error: line 9 column 28: unknown parameter 'model_compress'
 Legal parameters are:
   auto_config (bool) (default: true)
   debug_ref_count (bool) (default: false)
   dot_proof_file (string) (default: proof.dot)
   dump_models (bool) (default: false)
   memory_high_watermark (unsigned int) (default: 0)
   memory_max_alloc_count (unsigned int) (default: 0)
   memory_max_size (unsigned int) (default: 0)
   model (bool) (default: true)
   model_validate (bool) (default: false)
   proof (bool) (default: false)
   rlimit (unsigned int) (default: 0)
   smtlib2_compliant (bool) (default: false)
   stats (bool) (default: false)
   timeout (unsigned int) (default: 4294967295)
   trace (bool) (default: false)
   trace_file_name (string) (default: z3.log)
   type_check (bool) (default: true)
   unsat_core (bool) (default: false)
   verbose (unsigned int) (default: 0)
   warning (bool) (default: true)
   well_sorted_check (bool) (default: false)
 
 Fatal Error: ProverException: Prover died with no further output, perhaps it ran out of memory or was killed.
 Prover error: line 9 column 28: unknown parameter 'model_compress'
 Legal parameters are:
   auto_config (bool) (default: true)
   debug_ref_count (bool) (default: false)
   dot_proof_file (string) (default: proof.dot)
   dump_models (bool) (default: false)
   memory_high_watermark (unsigned int) (default: 0)
   memory_max_alloc_count (unsigned int) (default: 0)
   memory_max_size (unsigned int) (default: 0)
   model (bool) (default: true)
   model_validate (bool) (default: false)
   proof (bool) (default: false)
   rlimit (unsigned int) (default: 0)
   smtlib2_compliant (bool) (default: false)
   stats (bool) (default: false)
   timeout (unsigned int) (default: 4294967295)
   trace (bool) (default: false)
   trace_file_name (string) (default: z3.log)
   type_check (bool) (default: true)
   unsat_core (bool) (default: false)
   verbose (unsigned int) (default: 0)
   warning (bool) (default: true)
   well_sorted_check (bool) (default: false)
 
 Fatal Error: ProverException: Prover died with no further output, perhaps it ran out of memory or was killed.
 Prover error: line 9 column 28: unknown parameter 'model_compress'
 Legal parameters are:
   auto_config (bool) (default: true)
   debug_ref_count (bool) (default: false)
   dot_proof_file (string) (default: proof.dot)
   dump_models (bool) (default: false)
   memory_high_watermark (unsigned int) (default: 0)
   memory_max_alloc_count (unsigned int) (default: 0)
   memory_max_size (unsigned int) (default: 0)
   model (bool) (default: true)
   model_validate (bool) (default: false)
   proof (bool) (default: false)
   rlimit (unsigned int) (default: 0)
   smtlib2_compliant (bool) (default: false)
   stats (bool) (default: false)
   timeout (unsigned int) (default: 4294967295)
   trace (bool) (default: false)
   trace_file_name (string) (default: z3.log)
   type_check (bool) (default: true)
   unsat_core (bool) (default: false)
   verbose (unsigned int) (default: 0)
   warning (bool) (default: true)
   well_sorted_check (bool) (default: false)
 
 Fatal Error: ProverException: Prover died with no further output, perhaps it ran out of memory or was killed.
 Prover error: line 9 column 28: unknown parameter 'model_compress'
 Legal parameters are:
   auto_config (bool) (default: true)
   debug_ref_count (bool) (default: false)
   dot_proof_file (string) (default: proof.dot)
   dump_models (bool) (default: false)
   memory_high_watermark (unsigned int) (default: 0)
   memory_max_alloc_count (unsigned int) (default: 0)
   memory_max_size (unsigned int) (default: 0)
   model (bool) (default: true)
   model_validate (bool) (default: false)
   proof (bool) (default: false)
   rlimit (unsigned int) (default: 0)
   smtlib2_compliant (bool) (default: false)
   stats (bool) (default: false)
   timeout (unsigned int) (default: 4294967295)
   trace (bool) (default: false)
   trace_file_name (string) (default: z3.log)
   type_check (bool) (default: true)
   unsat_core (bool) (default: false)
   verbose (unsigned int) (default: 0)
   warning (bool) (default: true)
   well_sorted_check (bool) (default: false)
 
 Fatal Error: ProverException: Prover died with no further output, perhaps it ran out of memory or was killed.
 
 }
 
 Error:
 ERROR: Could not find a match for Check Directive (TestFiles/LitTests/LitTest/DafnyTestGeneration/TestGeneration.dfy:8 Pattern: '.*Passed!  - Failed:     0, Passed:     3, Skipped:     0, Total:     3*')
 Output:
 TestGeneration.dfy.tmp-tests.dfy(4,0): Error: rbrace expected
 1 parse errors detected in TestGeneration.dfy.tmp-tests.dfy
 
 Error:
 ERROR: Could not find a match for Check Directive (TestFiles/LitTests/LitTest/DafnyTestGeneration/TestGeneration.dfy:8 Pattern: '.*Passed!  - Failed:     0, Passed:     3, Skipped:     0, Total:     3*')
 Output:
 Test run for /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/DafnyTestGeneration/bin/Debug/net6.0/TestGeneration.dll (.NETCoreApp,Version=v6.0)
 Microsoft (R) Test Execution Command Line Tool Version 17.3.1 (x64)
 Copyright (c) Microsoft Corporation.  All rights reserved.
 
 Starting test execution, please wait...
 A total of 1 test files matched the specified pattern.
 No test is available in /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/DafnyTestGeneration/bin/Debug/net6.0/TestGeneration.dll. Make sure that test discoverer & executors are registered and platform & framework version settings are appropriate and try again.
 
 Additionally, path to test adapters can be specified using /TestAdapterPath command. Example  /TestAdapterPath:<pathToCustomAdapters>.
 
 Error:
 ERROR: Could not find a match for Check Directive (TestFiles/LitTests/LitTest/DafnyTestGeneration/TestGeneration.dfy:8 Pattern: '.*Passed!  - Failed:     0, Passed:     3, Skipped:     0, Total:     3*')


[xUnit.net 01:29:49.49]     dafny4/UnionFind.dfy [FAIL]
  Failed dafny4/UnionFind.dfy [25 m 43 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (4): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:3 /rprint:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny4/Output/UnionFind.dfy.tmp.rprint TestFiles/LitTests/LitTest/dafny4/UnionFind.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny4/Output/UnionFind.dfy.tmp
Output:
UnionFind.dfy[M2][M3](110,11): Verification of 'M3.UnionFind.Join (correctness)' timed out after 300 seconds
UnionFind.dfy(339,7): Verification of 'Main (correctness)' timed out after 300 seconds

Dafny program verifier finished with 61 verified, 0 errors, 2 time outs

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:3 /rprint:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny4/Output/UnionFind.dfy.tmp.rprint TestFiles/LitTests/LitTest/dafny4/UnionFind.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/dafny4/Output/UnionFind.dfy.tmp
 Previous command results:


[xUnit.net 01:35:17.94]     git-issues/git-issue-1207.dfy [FAIL]
  Failed git-issues/git-issue-1207.dfy [25 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/git-issues/git-issue-1207.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-1207.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
 git-issue-1207.dfy(17,9): Warning: /!\ No terms found to trigger on.
 git-issue-1207.dfy(29,9): Warning: /!\ No terms found to trigger on.
 git-issue-1207.dfy(41,9): Warning: /!\ No terms found to trigger on.
 git-issue-1207.dfy(47,9): Warning: /!\ No terms found to trigger on.
 git-issue-1207.dfy(48,9): Warning: /!\ No terms found to trigger on.
 git-issue-1207.dfy(10,9): Error: assertion might not hold
 git-issue-1207.dfy(11,9): Error: assertion might not hold
 git-issue-1207.dfy(14,9): Error: assertion might not hold
 git-issue-1207.dfy(15,9): Error: assertion might not hold
 git-issue-1207.dfy(16,9): Error: assertion might not hold
 git-issue-1207.dfy(22,9): Error: assertion might not hold
 git-issue-1207.dfy(23,9): Error: assertion might not hold
 git-issue-1207.dfy(24,9): Error: assertion might not hold
 git-issue-1207.dfy(26,9): Error: assertion might not hold
 git-issue-1207.dfy(27,9): Error: assertion might not hold
 git-issue-1207.dfy(34,9): Error: assertion might not hold
 git-issue-1207.dfy(35,9): Error: assertion might not hold
 git-issue-1207.dfy(38,9): Error: assertion might not hold
 git-issue-1207.dfy(39,9): Error: assertion might not hold
 git-issue-1207.dfy(40,9): Error: assertion might not hold
 git-issue-1207.dfy(47,9): Error: assertion might not hold
 git-issue-1207.dfy(48,9): Error: assertion might not hold
 git-issue-1207.dfy(49,9): Error: assertion might not hold
-git-issue-1207.dfy(50,49): Error: index out of range
-git-issue-1207.dfy(50,57): Error: index out of range
+git-issue-1207.dfy(50,9): Error: assertion might not hold
+git-issue-1207.dfy(51,9): Error: assertion might not hold
 
 Dafny program verifier finished with 0 verified, 20 errors
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 TestFiles/LitTests/LitTest/git-issues/git-issue-1207.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-1207.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/git-issues/git-issue-1207.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-1207.dfy.tmp
 Previous command results:
 Output:
 git-issue-1207.dfy(17,9): Warning: /!\ No terms found to trigger on.
 git-issue-1207.dfy(29,9): Warning: /!\ No terms found to trigger on.
 git-issue-1207.dfy(41,9): Warning: /!\ No terms found to trigger on.
 git-issue-1207.dfy(47,9): Warning: /!\ No terms found to trigger on.
 git-issue-1207.dfy(48,9): Warning: /!\ No terms found to trigger on.
 git-issue-1207.dfy(10,9): Error: assertion might not hold
 git-issue-1207.dfy(11,9): Error: assertion might not hold
 git-issue-1207.dfy(14,9): Error: assertion might not hold
 git-issue-1207.dfy(15,9): Error: assertion might not hold
 git-issue-1207.dfy(16,9): Error: assertion might not hold
 git-issue-1207.dfy(22,9): Error: assertion might not hold
 git-issue-1207.dfy(23,9): Error: assertion might not hold
 git-issue-1207.dfy(24,9): Error: assertion might not hold
 git-issue-1207.dfy(26,9): Error: assertion might not hold
 git-issue-1207.dfy(27,9): Error: assertion might not hold
 git-issue-1207.dfy(34,9): Error: assertion might not hold
 git-issue-1207.dfy(35,9): Error: assertion might not hold
 git-issue-1207.dfy(38,9): Error: assertion might not hold
 git-issue-1207.dfy(39,9): Error: assertion might not hold
 git-issue-1207.dfy(40,9): Error: assertion might not hold
 git-issue-1207.dfy(47,9): Error: assertion might not hold
 git-issue-1207.dfy(48,9): Error: assertion might not hold
 git-issue-1207.dfy(49,9): Error: assertion might not hold
 git-issue-1207.dfy(50,9): Error: assertion might not hold
 git-issue-1207.dfy(51,9): Error: assertion might not hold
 
 Dafny program verifier finished with 0 verified, 20 errors
 
 Error:
 


[xUnit.net 01:36:10.99]     git-issues/git-issue-1252.dfy [FAIL]
  Failed git-issues/git-issue-1252.dfy [32 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/git-issues/git-issue-1252.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-1252.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
 git-issue-1252.dfy(41,2): Warning: the modify statement with a block statement is deprecated
 git-issue-1252.dfy(93,13): Error: target object might be null
 git-issue-1252.dfy(94,10): Error: target object might be null
 git-issue-1252.dfy(93,13): Error: target object might be null
 git-issue-1252.dfy(94,10): Error: target object might be null
 git-issue-1252.dfy(30,11): Error: target object might be null
 git-issue-1252.dfy(37,11): Error: target object might be null
 git-issue-1252.dfy(45,13): Error: target object might be null
 git-issue-1252.dfy(51,14): Error: possible division by zero
 git-issue-1252.dfy(59,15): Error: target object might be null
 git-issue-1252.dfy(70,15): Error: target object might be null
 git-issue-1252.dfy(81,15): Error: target object might be null
 git-issue-1252.dfy(87,13): Error: target object might be null
 git-issue-1252.dfy(100,25): Error: target object might be null
-git-issue-1252.dfy(106,21): Error: target object might be null
 git-issue-1252.dfy(106,21): Error: object might be null
 git-issue-1252.dfy(106,21): Error: object might not be allocated in the old-state of the 'unchanged' predicate
+git-issue-1252.dfy(106,21): Error: target object might be null
 
 Dafny program verifier finished with 4 verified, 16 errors
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 TestFiles/LitTests/LitTest/git-issues/git-issue-1252.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-1252.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/git-issues/git-issue-1252.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-1252.dfy.tmp
 Previous command results:
 Output:
 git-issue-1252.dfy(41,2): Warning: the modify statement with a block statement is deprecated
 git-issue-1252.dfy(93,13): Error: target object might be null
 git-issue-1252.dfy(94,10): Error: target object might be null
 git-issue-1252.dfy(93,13): Error: target object might be null
 git-issue-1252.dfy(94,10): Error: target object might be null
 git-issue-1252.dfy(30,11): Error: target object might be null
 git-issue-1252.dfy(37,11): Error: target object might be null
 git-issue-1252.dfy(45,13): Error: target object might be null
 git-issue-1252.dfy(51,14): Error: possible division by zero
 git-issue-1252.dfy(59,15): Error: target object might be null
 git-issue-1252.dfy(70,15): Error: target object might be null
 git-issue-1252.dfy(81,15): Error: target object might be null
 git-issue-1252.dfy(87,13): Error: target object might be null
 git-issue-1252.dfy(100,25): Error: target object might be null
 git-issue-1252.dfy(106,21): Error: object might be null
 git-issue-1252.dfy(106,21): Error: object might not be allocated in the old-state of the 'unchanged' predicate
 git-issue-1252.dfy(106,21): Error: target object might be null
 
 Dafny program verifier finished with 4 verified, 16 errors
 
 Error:
 


[xUnit.net 01:41:27.05]     git-issues/git-issue-2026.dfy [FAIL]
  Failed git-issues/git-issue-2026.dfy [27 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/git-issues/git-issue-2026.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-2026.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
 git-issue-2026.dfy(11,18): Error: This loop invariant might not be maintained by the loop.
 git-issue-2026.dfy(11,18): Related message: loop invariant violation
 git-issue-2026.dfy(12,18): Error: This loop invariant might not be maintained by the loop.
 git-issue-2026.dfy(12,18): Related message: loop invariant violation
 
 Dafny program verifier finished with 0 verified, 2 errors
 Counterexample for first failing assertion: 
 git-issue-2026.dfy(5,0): initial state:
-	n : int = 5854
-	ret : ? = ()
+	n : int = 8099
+	ret : _System.array?<seq<char>> = ()
 git-issue-2026.dfy(6,24):
-Please enable /proverOpt:O:model_compress=false (for z3 version < 4.8.7) or /proverOpt:O:model.compact=false (for z3 version >= 4.8.7), otherwise you'll get unexpected values.
-	n : int = 5854
-	ret : ? = ([null] := @0)
+	n : int = 8099
+	ret : _System.array?<seq<char>> = (Length := 8099, [0] := @0)
+	@0 : seq<char> = ['o', 'd', 'd']
-	@0 : ? = ()
 git-issue-2026.dfy(8,14):
-Please enable /proverOpt:O:model_compress=false (for z3 version < 4.8.7) or /proverOpt:O:model.compact=false (for z3 version >= 4.8.7), otherwise you'll get unexpected values.
-	n : int = 5854
+	n : int = 8099
+	ret : _System.array?<seq<char>> = (Length := 8099, [0] := @0)
-	ret : ? = ([null] := @0)
 	i : int = 0
-	@0 : ? = ()
+	@0 : seq<char> = ['o', 'd', 'd']
 git-issue-2026.dfy(9,4): after some loop iterations:
-	n : int = 5854
-	ret : ? = ()
+	n : int = 8099
+	ret : _System.array?<seq<char>> = (Length := 8099)
 	i : int = 0
 git-issue-2026.dfy(15,27):
-Please enable /proverOpt:O:model_compress=false (for z3 version < 4.8.7) or /proverOpt:O:model.compact=false (for z3 version >= 4.8.7), otherwise you'll get unexpected values.
-	n : int = 5854
+	n : int = 8099
+	ret : _System.array?<seq<char>> = (Length := 8099, [0] := @0)
-	ret : ? = ([null] := @0)
 	i : int = 0
-	@0 : ? = ()
+	@0 : seq<char> = ['o', 'd', 'd']
 git-issue-2026.dfy(19,18):
-Please enable /proverOpt:O:model_compress=false (for z3 version < 4.8.7) or /proverOpt:O:model.compact=false (for z3 version >= 4.8.7), otherwise you'll get unexpected values.
-	n : int = 5854
+	n : int = 8099
+	ret : _System.array?<seq<char>> = (Length := 8099, [0] := @0)
-	ret : ? = ([null] := @0)
 	i : int = 1
-	@0 : ? = ()
+	@0 : seq<char> = ['o', 'd', 'd']
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 TestFiles/LitTests/LitTest/git-issues/git-issue-2026.dfy /extractCounterexample /mv model > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-2026.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/git-issues/git-issue-2026.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-2026.dfy.tmp
 Previous command results:
 Output:
 git-issue-2026.dfy(11,18): Error: This loop invariant might not be maintained by the loop.
 git-issue-2026.dfy(11,18): Related message: loop invariant violation
 git-issue-2026.dfy(12,18): Error: This loop invariant might not be maintained by the loop.
 git-issue-2026.dfy(12,18): Related message: loop invariant violation
 
 Dafny program verifier finished with 0 verified, 2 errors
 Counterexample for first failing assertion: 
 git-issue-2026.dfy(5,0): initial state:
 	n : int = 8099
 	ret : _System.array?<seq<char>> = ()
 git-issue-2026.dfy(6,24):
 	n : int = 8099
 	ret : _System.array?<seq<char>> = (Length := 8099, [0] := @0)
 	@0 : seq<char> = ['o', 'd', 'd']
 git-issue-2026.dfy(8,14):
 	n : int = 8099
 	ret : _System.array?<seq<char>> = (Length := 8099, [0] := @0)
 	i : int = 0
 	@0 : seq<char> = ['o', 'd', 'd']
 git-issue-2026.dfy(9,4): after some loop iterations:
 	n : int = 8099
 	ret : _System.array?<seq<char>> = (Length := 8099)
 	i : int = 0
 git-issue-2026.dfy(15,27):
 	n : int = 8099
 	ret : _System.array?<seq<char>> = (Length := 8099, [0] := @0)
 	i : int = 0
 	@0 : seq<char> = ['o', 'd', 'd']
 git-issue-2026.dfy(19,18):
 	n : int = 8099
 	ret : _System.array?<seq<char>> = (Length := 8099, [0] := @0)
 	i : int = 1
 	@0 : seq<char> = ['o', 'd', 'd']
 
 Error:
 


[xUnit.net 01:41:53.07]     git-issues/git-issue-2301.dfy [FAIL]
  Failed git-issues/git-issue-2301.dfy [26 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/git-issues/git-issue-2301.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-2301.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
 git-issue-2301.dfy(15,14): Error: insufficient reads clause to read state of 'unchanged' object
 git-issue-2301.dfy(23,11): Error: assertion might not hold
 git-issue-2301.dfy(10,4): Related location
 git-issue-2301.dfy(39,8): Error: insufficient reads clause to read state of 'unchanged' object
 git-issue-2301.dfy(40,8): Error: insufficient reads clause to read state of 'unchanged' object
 git-issue-2301.dfy(42,17): Error: insufficient reads clause to read state of 'unchanged' set element
 git-issue-2301.dfy(44,8): Error: insufficient reads clause to read state of 'unchanged' multiset element
 git-issue-2301.dfy(46,8): Error: insufficient reads clause to read state of 'unchanged' sequence element
+git-issue-2301.dfy(53,17): Error: insufficient reads clause to read state of 'unchanged' object
 
-Dafny program verifier finished with 3 verified, 7 errors
+Dafny program verifier finished with 2 verified, 8 errors
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 TestFiles/LitTests/LitTest/git-issues/git-issue-2301.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-2301.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/git-issues/git-issue-2301.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-2301.dfy.tmp
 Previous command results:
 Output:
 git-issue-2301.dfy(15,14): Error: insufficient reads clause to read state of 'unchanged' object
 git-issue-2301.dfy(23,11): Error: assertion might not hold
 git-issue-2301.dfy(10,4): Related location
 git-issue-2301.dfy(39,8): Error: insufficient reads clause to read state of 'unchanged' object
 git-issue-2301.dfy(40,8): Error: insufficient reads clause to read state of 'unchanged' object
 git-issue-2301.dfy(42,17): Error: insufficient reads clause to read state of 'unchanged' set element
 git-issue-2301.dfy(44,8): Error: insufficient reads clause to read state of 'unchanged' multiset element
 git-issue-2301.dfy(46,8): Error: insufficient reads clause to read state of 'unchanged' sequence element
 git-issue-2301.dfy(53,17): Error: insufficient reads clause to read state of 'unchanged' object
 
 Dafny program verifier finished with 2 verified, 8 errors
 
 Error:
 


[xUnit.net 01:41:57.47]     git-issues/git-issue-2299.dfy [FAIL]
  Failed git-issues/git-issue-2299.dfy [30 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/git-issues/git-issue-2299.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-2299.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
 git-issue-2299.dfy(37,11): Error: assertion might not hold
 git-issue-2299.dfy(10,11): Related location
 git-issue-2299.dfy(48,11): Error: assertion might not hold
 git-issue-2299.dfy(16,4): Related location
 git-issue-2299.dfy(58,11): Error: assertion might not hold
 git-issue-2299.dfy(21,4): Related location
 git-issue-2299.dfy(67,13): Error: assertion might not hold
 git-issue-2299.dfy(21,4): Related location
 git-issue-2299.dfy(81,11): Error: assertion might not hold
-git-issue-2299.dfy(27,4): Related location
-git-issue-2299.dfy(10,11): Related location
-git-issue-2299.dfy(81,11): Error: assertion might not hold
 git-issue-2299.dfy(27,18): Related location
 git-issue-2299.dfy(16,4): Related location
 git-issue-2299.dfy(81,11): Error: assertion might not hold
 git-issue-2299.dfy(27,32): Related location
 git-issue-2299.dfy(21,4): Related location
+git-issue-2299.dfy(81,11): Error: assertion might not hold
+git-issue-2299.dfy(27,4): Related location
+git-issue-2299.dfy(10,11): Related location
 
 Dafny program verifier finished with 7 verified, 7 errors
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 TestFiles/LitTests/LitTest/git-issues/git-issue-2299.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-2299.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/git-issues/git-issue-2299.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-2299.dfy.tmp
 Previous command results:
 Output:
 git-issue-2299.dfy(37,11): Error: assertion might not hold
 git-issue-2299.dfy(10,11): Related location
 git-issue-2299.dfy(48,11): Error: assertion might not hold
 git-issue-2299.dfy(16,4): Related location
 git-issue-2299.dfy(58,11): Error: assertion might not hold
 git-issue-2299.dfy(21,4): Related location
 git-issue-2299.dfy(67,13): Error: assertion might not hold
 git-issue-2299.dfy(21,4): Related location
 git-issue-2299.dfy(81,11): Error: assertion might not hold
 git-issue-2299.dfy(27,18): Related location
 git-issue-2299.dfy(16,4): Related location
 git-issue-2299.dfy(81,11): Error: assertion might not hold
 git-issue-2299.dfy(27,32): Related location
 git-issue-2299.dfy(21,4): Related location
 git-issue-2299.dfy(81,11): Error: assertion might not hold
 git-issue-2299.dfy(27,4): Related location
 git-issue-2299.dfy(10,11): Related location
 
 Dafny program verifier finished with 7 verified, 7 errors
 
 Error:
 


[xUnit.net 01:42:47.89]     git-issues/git-issue-2605.dfy [FAIL]
  Failed git-issues/git-issue-2605.dfy [23 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): DiffCommand TestFiles/LitTests/LitTest/git-issues/git-issue-2605.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-2605.dfy.tmp
Output:
AssertEqualWithDiff() Failure
Diff (changing expected into actual):
 git-issue-2605.dfy(6,14): Error: possible division by zero
 git-issue-2605.dfy(6,23): Error: possible division by zero
-git-issue-2605.dfy(7,13): Error: index out of range
 git-issue-2605.dfy(7,21): Error: index out of range
 git-issue-2605.dfy(9,11): Error: assertion might not hold
+git-issue-2605.dfy(11,9): Error: assertion might not hold
 
 Dafny program verifier finished with 0 verified, 5 errors
 

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 TestFiles/LitTests/LitTest/git-issues/git-issue-2605.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-2605.dfy.tmp
 Executing command: DiffCommand TestFiles/LitTests/LitTest/git-issues/git-issue-2605.dfy.expect /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-2605.dfy.tmp
 Previous command results:
 Output:
 git-issue-2605.dfy(6,14): Error: possible division by zero
 git-issue-2605.dfy(6,23): Error: possible division by zero
 git-issue-2605.dfy(7,21): Error: index out of range
 git-issue-2605.dfy(9,11): Error: assertion might not hold
 git-issue-2605.dfy(11,9): Error: assertion might not hold
 
 Dafny program verifier finished with 0 verified, 5 errors
 
 Error:
 


[xUnit.net 01:49:58.34]     git-issues/git-issue-401.dfy [FAIL]
  Failed git-issues/git-issue-401.dfy [27 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (1): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /proverOpt:PROVER_PATH=z3/bin/z3 TestFiles/LitTests/LitTest/git-issues/git-issue-401.dfy >> /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-401.dfy.tmp
Output:
*** ProverException: Requested prover not found: 'z3/bin/z3'

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 TestFiles/LitTests/LitTest/git-issues/git-issue-401.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-401.dfy.tmp
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /proverOpt:PROVER_PATH=z3/bin/z3 TestFiles/LitTests/LitTest/git-issues/git-issue-401.dfy >> /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-401.dfy.tmp
 Previous command results:
 Output:
 
 Dafny program verifier finished with 1 verified, 0 errors
 
 Error:
 


[xUnit.net 01:54:29.96]     git-issues/git-issue-356.dfy [FAIL]
  Failed git-issues/git-issue-356.dfy [5 m 47 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (4): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 TestFiles/LitTests/LitTest/git-issues/git-issue-356.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-356.dfy.tmp
Output:
git-issue-356.dfy(66,12): Error: bit-vector value to be converted might not fit in char

Dafny program verifier finished with 24 verified, 1 error

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 TestFiles/LitTests/LitTest/git-issues/git-issue-356.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-356.dfy.tmp
 Previous command results:


[xUnit.net 01:54:48.31]     git-issues/git-issue-505.dfy [FAIL]
  Failed git-issues/git-issue-505.dfy [43 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (4): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /timeLimit:20 TestFiles/LitTests/LitTest/git-issues/git-issue-505.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-505.dfy.tmp
Output:
git-issue-505.dfy(4,6): Verification of 'd (correctness)' timed out after 20 seconds

Dafny program verifier finished with 1 verified, 0 errors, 1 time out

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /timeLimit:20 TestFiles/LitTests/LitTest/git-issues/git-issue-505.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/git-issues/Output/git-issue-505.dfy.tmp
 Previous command results:


[xUnit.net 02:30:39.41]     libraries/src/Collections/Sequences/Seq.dfy [FAIL]
  Failed libraries/src/Collections/Sequences/Seq.dfy [5 m 8 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (4): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 TestFiles/LitTests/LitTest/libraries/src/Collections/Sequences/Seq.dfy
Output:
Seq.dfy(183,13): Error: assertion might not hold

Dafny program verifier finished with 70 verified, 1 error

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 TestFiles/LitTests/LitTest/libraries/src/Collections/Sequences/Seq.dfy
 Previous command results:


[xUnit.net 02:30:46.22]     libraries/src/Collections/Sequences/LittleEndianNat.dfy [FAIL]
  Failed libraries/src/Collections/Sequences/LittleEndianNat.dfy [6 m 26 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (4): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /noNLarith TestFiles/LitTests/LitTest/libraries/src/Collections/Sequences/LittleEndianNat.dfy
Output:
LittleEndianNat.dfy(257,23): Error: A precondition for this call might not hold.
LittleEndianNat.dfy(237,33): Related location: This is the precondition that might not hold.

Dafny program verifier finished with 40 verified, 1 error

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /noNLarith TestFiles/LitTests/LitTest/libraries/src/Collections/Sequences/LittleEndianNat.dfy
 Previous command results:


[xUnit.net 02:39:22.01]     libraries/src/NonlinearArithmetic/Power.dfy [FAIL]
  Failed libraries/src/NonlinearArithmetic/Power.dfy [7 m 55 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (4): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /noNLarith TestFiles/LitTests/LitTest/libraries/src/NonlinearArithmetic/Power.dfy
Output:
Power.dfy(324,8): Verification of 'Power.LemmaPowAuto (correctness)' timed out after 300 seconds

Dafny program verifier finished with 58 verified, 0 errors, 1 time out

Error:

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /noNLarith TestFiles/LitTests/LitTest/libraries/src/NonlinearArithmetic/Power.dfy
 Previous command results:


[xUnit.net 02:42:20.87]     server/counterexample_commandline.dfy [FAIL]
  Failed server/counterexample_commandline.dfy [1 m 44 s]
  Error Message:
   System.Exception : Command returned non-zero exit code (134): dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /proverOpt:O:model_compress=false /proverOpt:O:model.completion=true /warnShadowing /extractCounterexample /mv:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/server/Output/counterexample_commandline.dfy.tmp.model TestFiles/LitTests/LitTest/server/counterexample_commandline.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/server/Output/counterexample_commandline.dfy.tmp
Output:
Prover error: line 9 column 28: unknown parameter 'model_compress'
Legal parameters are:
  auto_config (bool) (default: true)
  debug_ref_count (bool) (default: false)
  dot_proof_file (string) (default: proof.dot)
  dump_models (bool) (default: false)
  memory_high_watermark (unsigned int) (default: 0)
  memory_max_alloc_count (unsigned int) (default: 0)
  memory_max_size (unsigned int) (default: 0)
  model (bool) (default: true)
  model_validate (bool) (default: false)
  proof (bool) (default: false)
  rlimit (unsigned int) (default: 0)
  smtlib2_compliant (bool) (default: false)
  stats (bool) (default: false)
  timeout (unsigned int) (default: 4294967295)
  trace (bool) (default: false)
  trace_file_name (string) (default: z3.log)
  type_check (bool) (default: true)
  unsat_core (bool) (default: false)
  verbose (unsigned int) (default: 0)
  warning (bool) (default: true)
  well_sorted_check (bool) (default: false)

Prover error: line 9 column 28: unknown parameter 'model_compress'
Legal parameters are:
  auto_config (bool) (default: true)
  debug_ref_count (bool) (default: false)
  dot_proof_file (string) (default: proof.dot)
  dump_models (bool) (default: false)
  memory_high_watermark (unsigned int) (default: 0)
  memory_max_alloc_count (unsigned int) (default: 0)
  memory_max_size (unsigned int) (default: 0)
  model (bool) (default: true)
  model_validate (bool) (default: false)
  proof (bool) (default: false)
  rlimit (unsigned int) (default: 0)
  smtlib2_compliant (bool) (default: false)
  stats (bool) (default: false)
  timeout (unsigned int) (default: 4294967295)
  trace (bool) (default: false)
  trace_file_name (string) (default: z3.log)
  type_check (bool) (default: true)
  unsat_core (bool) (default: false)
  verbose (unsigned int) (default: 0)
  warning (bool) (default: true)
  well_sorted_check (bool) (default: false)

Fatal Error: ProverException: Prover died with no further output, perhaps it ran out of memory or was killed.

Error:
Unhandled exception. System.AggregateException: One or more errors occurred. (Could not find file '/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/server/Output/counterexample_commandline.dfy.tmp.model'.)
 ---> System.IO.FileNotFoundException: Could not find file '/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/server/Output/counterexample_commandline.dfy.tmp.model'.
File name: '/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/server/Output/counterexample_commandline.dfy.tmp.model'
   at Interop.ThrowExceptionForIoErrno(ErrorInfo errorInfo, String path, Boolean isDirectory, Func`2 errorRewriter)
   at Microsoft.Win32.SafeHandles.SafeFileHandle.Open(String path, OpenFlags flags, Int32 mode)
   at Microsoft.Win32.SafeHandles.SafeFileHandle.Open(String fullPath, FileMode mode, FileAccess access, FileShare share, FileOptions options, Int64 preallocationSize)
   at System.IO.Strategies.OSFileStreamStrategy..ctor(String path, FileMode mode, FileAccess access, FileShare share, FileOptions options, Int64 preallocationSize)
   at System.IO.Strategies.FileStreamHelpers.ChooseStrategy(FileStream fileStream, String path, FileMode mode, FileAccess access, FileShare share, Int32 bufferSize, FileOptions options, Int64 preallocationSize)
   at System.IO.StreamReader.ValidateArgsAndOpenPath(String path, Encoding encoding, Int32 bufferSize)
   at System.IO.File.InternalReadAllText(String path, Encoding encoding)
   at System.IO.File.ReadAllText(String path)
   at Microsoft.Dafny.DafnyDriver.PrintCounterexample(String modelViewFile) in /home/livia/dafny/Source/DafnyDriver/DafnyDriver.cs:line 362
   at Microsoft.Dafny.DafnyDriver.ProcessFilesAsync(IList`1 dafnyFiles, ReadOnlyCollection`1 otherFileNames, ErrorReporter reporter, Boolean lookForSnapshots, String programId) in /home/livia/dafny/Source/DafnyDriver/DafnyDriver.cs:line 350
   --- End of inner exception stack trace ---
   at System.Threading.Tasks.Task.ThrowIfExceptional(Boolean includeTaskCanceledExceptions)
   at System.Threading.Tasks.Task`1.GetResultCore(Boolean waitCompletionNotification)
   at System.Threading.Tasks.Task`1.get_Result()
   at Microsoft.Dafny.DafnyDriver.ThreadMain(String[] args) in /home/livia/dafny/Source/DafnyDriver/DafnyDriver.cs:line 122
   at Microsoft.Dafny.DafnyDriver.<>c__DisplayClass10_0.<Main>b__0() in /home/livia/dafny/Source/DafnyDriver/DafnyDriver.cs:line 99
   at System.Threading.Thread.StartCallback()

  Stack Trace:
     at XUnitExtensions.Lit.LitTestCase.Execute(ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 94
   at XUnitExtensions.Lit.LitTestCase.Run(String filePath, LitTestConfiguration config, ITestOutputHelper outputHelper) in /home/livia/dafny/Source/XUnitExtensions/Lit/LitTestCase.cs:line 55
   at IntegrationTests.LitTests.LitTest(String path) in /home/livia/dafny/Source/IntegrationTests/LitTests.cs:line 140
  Standard Output Messages:
 Executing command: dotnet /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/Dafny.dll /countVerificationErrors:0 /vcsCores:2 /useBaseNameForFileName /compileVerbose:0 /timeLimit:300 /compile:0 /proverOpt:O:model_compress=false /proverOpt:O:model.completion=true /warnShadowing /extractCounterexample /mv:/home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/server/Output/counterexample_commandline.dfy.tmp.model TestFiles/LitTests/LitTest/server/counterexample_commandline.dfy > /home/livia/dafny/Source/IntegrationTests/bin/Debug/net6.0/TestFiles/LitTests/LitTest/server/Output/counterexample_commandline.dfy.tmp
 Previous command results:


